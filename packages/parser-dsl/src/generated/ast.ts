/******************************************************************************
 * This file was generated by langium-cli 4.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const RuniqTerminals = {
    ANCHORED_ARROW: /-(north|south|east|west)(-"[^"]*")?->(north|south|east|west)?/,
    LABELED_ARROW: /-[a-zA-Z_][a-zA-Z0-9_-]*->/,
    BIDIRECTIONAL_ARROW: /<->/,
    ARROW: /->/,
    TAG: /[A-Z][A-Z0-9]*-[0-9]{1,4}[A-Z]?/,
    SHAPE_ID: /[a-z_][a-zA-Z0-9_]*-[a-zA-Z0-9_-]*/,
    ID: /[a-zA-Z_][a-zA-Z0-9_]*/,
    STRING: /"(?:[^"\\]|\\.)*"/,
    NUMBER: /-?[0-9]+(\.[0-9]+)?/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /(\/\/|#)[^\n\r]*/,
};

export type RuniqTerminalNames = keyof typeof RuniqTerminals;

export type RuniqKeywordNames =
    | "${"
    | "%"
    | "("
    | ")"
    | ","
    | "."
    | ".."
    | "/"
    | "150#"
    | "1500#"
    | "2500#"
    | "300#"
    | "600#"
    | "900#"
    | ":"
    | "="
    | "@"
    | "Alloy20"
    | "BT"
    | "CFM"
    | "CS"
    | "DN"
    | "GPM"
    | "Hastelloy"
    | "K"
    | "L"
    | "L/min"
    | "L/s"
    | "LR"
    | "MPa"
    | "Monel"
    | "NPS"
    | "PN10"
    | "PN16"
    | "PN25"
    | "PN40"
    | "PP"
    | "PTFE"
    | "PVC"
    | "RL"
    | "SCH10"
    | "SCH100"
    | "SCH120"
    | "SCH140"
    | "SCH160"
    | "SCH20"
    | "SCH30"
    | "SCH40"
    | "SCH5"
    | "SCH60"
    | "SCH80"
    | "SS304"
    | "SS316"
    | "SS316L"
    | "STD"
    | "TB"
    | "Titanium"
    | "XS"
    | "XXS"
    | "["
    | "]"
    | "abstract:"
    | "ac"
    | "acceptEvent"
    | "accuracy:"
    | "acoustic"
    | "action"
    | "activate:"
    | "activity"
    | "activityFinal"
    | "actor"
    | "affected:"
    | "aggregation"
    | "agitator"
    | "airCooler"
    | "algorithm:"
    | "alignContent:"
    | "alt"
    | "alternating"
    | "alternatives:"
    | "analysis"
    | "analyzerTransmitter"
    | "anchor"
    | "and"
    | "api"
    | "arrowType:"
    | "artifact"
    | "as"
    | "assembly"
    | "association"
    | "async"
    | "attributes:"
    | "auto"
    | "autoResize:"
    | "badge:"
    | "balance"
    | "bar"
    | "bbl"
    | "bbl/day"
    | "betweenness"
    | "bidirectional"
    | "biodegradable"
    | "boolean"
    | "borderRadius:"
    | "borderStyle:"
    | "bottom"
    | "bottom-left"
    | "bottom-right"
    | "boundary"
    | "branch"
    | "break"
    | "cache"
    | "call"
    | "callout"
    | "callouts"
    | "carrier:"
    | "cascade"
    | "center"
    | "centerLabel"
    | "central"
    | "centralBuffer"
    | "child"
    | "childCountPosition:"
    | "children:"
    | "circle"
    | "circles"
    | "circular"
    | "closeness"
    | "clustering"
    | "cm"
    | "collaboration"
    | "collapseAnimationDuration:"
    | "collapseAnimationEasing:"
    | "collapseButtonColor:"
    | "collapseButtonPosition:"
    | "collapseButtonSize:"
    | "collapseButtonStyle:"
    | "collapseButtonVisible:"
    | "collapseIcon:"
    | "collapseKeyboardShortcut:"
    | "collapseMode:"
    | "collapsePersistState:"
    | "collapseRedirectEdges:"
    | "collapseShowCount:"
    | "collapseStateKey:"
    | "collapseSummary:"
    | "collapseTransitionState:"
    | "collapsed:"
    | "collapsible:"
    | "collapsing"
    | "color"
    | "colorScheme"
    | "colorful"
    | "colors:"
    | "columnHeaders"
    | "columns"
    | "complex"
    | "component"
    | "composition"
    | "compressorCentrifugal"
    | "compressorReciprocating"
    | "condenser"
    | "conductivity"
    | "conductivityTransmitter"
    | "config"
    | "constraint:"
    | "constraints:"
    | "container"
    | "container-aware"
    | "continuation"
    | "control"
    | "control_room"
    | "controlled_variable:"
    | "controller:"
    | "cool"
    | "cooler"
    | "coolingTower"
    | "create"
    | "critical"
    | "crossContainerEdgeOptimization:"
    | "cyclone"
    | "dashed"
    | "data"
    | "data:"
    | "dataStore"
    | "database"
    | "datasource"
    | "date:"
    | "db"
    | "dc"
    | "deceased:"
    | "default:"
    | "degC"
    | "degF"
    | "degree"
    | "delimiter"
    | "dependency"
    | "depth:"
    | "depthIndicatorStyle:"
    | "derived:"
    | "description"
    | "description:"
    | "destroy"
    | "detail"
    | "diagram"
    | "digital"
    | "dimension:"
    | "direction"
    | "direction:"
    | "distillationColumn"
    | "distribution:"
    | "doActivity:"
    | "done"
    | "dotted"
    | "double"
    | "durationConstraint"
    | "e"
    | "easeIn"
    | "easeInOut"
    | "easeOut"
    | "edge"
    | "edgeBundling:"
    | "edgeRouting:"
    | "edgeType:"
    | "effect:"
    | "electrical"
    | "end"
    | "endDate:"
    | "entity"
    | "entry:"
    | "entryPoint"
    | "equipment"
    | "event"
    | "event:"
    | "eventBased"
    | "events"
    | "evolution:"
    | "evolve"
    | "exclusive"
    | "exit:"
    | "exitPoint"
    | "expanding"
    | "extends:"
    | "extensionPoints:"
    | "f"
    | "false"
    | "fan"
    | "feedforward"
    | "field"
    | "fill-available"
    | "fillColor:"
    | "filter"
    | "filter:"
    | "finalState"
    | "firedHeater"
    | "fireproof"
    | "fit-content"
    | "flashDrum"
    | "flipAxes:"
    | "flow"
    | "flowAlarmHigh"
    | "flowAlarmLow"
    | "flowController"
    | "flowFinal"
    | "flowIndicator"
    | "flowIndicatorController"
    | "flowRate"
    | "flowRate:"
    | "flowRecorder"
    | "flowSwitch"
    | "flowTransmitter"
    | "flowType:"
    | "fluid"
    | "fontFamily:"
    | "fontSize:"
    | "fontWeight:"
    | "for"
    | "force"
    | "foreach"
    | "forest"
    | "format"
    | "found"
    | "fragment"
    | "frame"
    | "frameStyle"
    | "from"
    | "from:"
    | "ft"
    | "ft³"
    | "full"
    | "future"
    | "gal"
    | "gal/min"
    | "gates:"
    | "gatewayType:"
    | "generalization"
    | "genericTypes:"
    | "glyphset"
    | "group"
    | "groups"
    | "guard:"
    | "header"
    | "header:"
    | "headerBackgroundColor:"
    | "headerPosition:"
    | "heatExchangerPlate"
    | "heatExchangerShellTube"
    | "high"
    | "history"
    | "historyDeep"
    | "historyShallow"
    | "hollow"
    | "horizontal"
    | "horizontalAxis"
    | "hoverBorderColor:"
    | "hoverBorderWidth:"
    | "hoverHighlight:"
    | "hub"
    | "hydraulic"
    | "icon"
    | "icon-text"
    | "icon:"
    | "iconColor:"
    | "iconSize:"
    | "id"
    | "if"
    | "image"
    | "images"
    | "in"
    | "inclusive"
    | "incrementalLayout:"
    | "indent"
    | "inertia:"
    | "initialState"
    | "input"
    | "inputPins:"
    | "inst"
    | "instrument"
    | "insulation:"
    | "intersections:"
    | "item"
    | "items"
    | "jacket"
    | "junction"
    | "kPa"
    | "key"
    | "key:"
    | "kg/h"
    | "knockoutDrum"
    | "label"
    | "label:"
    | "labelPosition:"
    | "labels:"
    | "layered"
    | "layout"
    | "layoutCache:"
    | "layoutComplexity:"
    | "leader"
    | "leaf"
    | "left"
    | "leftWeight"
    | "legendPosition:"
    | "level"
    | "levelAlarmHigh"
    | "levelAlarmHighHigh"
    | "levelAlarmLow"
    | "levelAlarmLowLow"
    | "levelController"
    | "levelIndicator"
    | "levelIndicatorController"
    | "levelSwitch"
    | "levelTransmitter"
    | "levels"
    | "lifeline"
    | "limit"
    | "limit:"
    | "line"
    | "lineStyle:"
    | "linear"
    | "link:"
    | "local"
    | "location:"
    | "loop"
    | "loop:"
    | "lost"
    | "low"
    | "m"
    | "manual"
    | "map:"
    | "margin:"
    | "marginBottom:"
    | "marginLeft:"
    | "marginRight:"
    | "marginTop:"
    | "material:"
    | "max"
    | "maxHeight:"
    | "maxWidth:"
    | "medium"
    | "member"
    | "mergePoint"
    | "message"
    | "methods:"
    | "metricPosition:"
    | "metricType:"
    | "middle"
    | "min"
    | "minHeight:"
    | "minResizeHeight:"
    | "minResizeWidth:"
    | "minWidth:"
    | "mindmap"
    | "mineral"
    | "mm"
    | "mm/s"
    | "mobile"
    | "mode:"
    | "module"
    | "monochrome"
    | "mrtree"
    | "multiplicitySource:"
    | "multiplicityTarget:"
    | "m³"
    | "m³/h"
    | "n"
    | "name"
    | "name:"
    | "navigability:"
    | "ne"
    | "net"
    | "node"
    | "nodeSpacing:"
    | "noise"
    | "none"
    | "note"
    | "number"
    | "nw"
    | "objectNode"
    | "ocean"
    | "of:"
    | "op"
    | "opacity:"
    | "open"
    | "operating"
    | "operator"
    | "opt"
    | "options:"
    | "or"
    | "orientation"
    | "orientation:"
    | "orthogonal"
    | "output"
    | "outputPins:"
    | "over"
    | "overlap"
    | "package"
    | "packed"
    | "padding:"
    | "paddingBottom:"
    | "paddingLeft:"
    | "paddingRight:"
    | "paddingTop:"
    | "panel"
    | "par"
    | "parallel"
    | "parameters:"
    | "params:"
    | "part"
    | "partial"
    | "participant"
    | "participants:"
    | "period"
    | "person"
    | "personnel_protection"
    | "ph"
    | "phTransmitter"
    | "phosphate-ester"
    | "pid"
    | "pill"
    | "pin"
    | "pins:"
    | "pneumatic"
    | "polyline"
    | "port"
    | "ports:"
    | "position:"
    | "ppm"
    | "preset"
    | "preset:"
    | "pressure"
    | "pressureAlarmHigh"
    | "pressureAlarmHighHigh"
    | "pressureAlarmLow"
    | "pressureAlarmLowLow"
    | "pressureController"
    | "pressureIndicator"
    | "pressureIndicatorController"
    | "pressureRecorder"
    | "pressureSwitch"
    | "pressureTransmitter"
    | "private"
    | "process"
    | "professional"
    | "protected"
    | "providedInterface"
    | "psi"
    | "public"
    | "pumpCentrifugal"
    | "pumpPositiveDisplacement"
    | "quadrant"
    | "quadrants"
    | "queue"
    | "radial"
    | "range:"
    | "rated"
    | "rating:"
    | "ratio"
    | "reactor"
    | "realization"
    | "reboiler"
    | "receiveSignal"
    | "ref"
    | "ref:"
    | "refluxDrum"
    | "relationship"
    | "relationship:"
    | "remote"
    | "requiredInterface"
    | "resizable:"
    | "resizeHandles:"
    | "result"
    | "return"
    | "returnType:"
    | "right"
    | "rightWeight"
    | "roleSource:"
    | "roleTarget:"
    | "root"
    | "routing"
    | "routing:"
    | "rowHeaders"
    | "rpm"
    | "runiq"
    | "ruptureDisk"
    | "s"
    | "schedule:"
    | "schematic"
    | "se"
    | "segments"
    | "selectionBorderColor:"
    | "selectionBorderWidth:"
    | "selectionHighlight:"
    | "sendSignal"
    | "separator"
    | "separatorHorizontal"
    | "sequence"
    | "setpoint:"
    | "settings"
    | "shadow:"
    | "shape"
    | "shape:"
    | "showAllConnections"
    | "showChildCount:"
    | "showConnections"
    | "showDepthIndicator:"
    | "showDottedLines"
    | "showLegend:"
    | "showMetrics:"
    | "showPercentages"
    | "showValues"
    | "showValues:"
    | "side"
    | "sides"
    | "signal"
    | "size:"
    | "solid"
    | "source"
    | "source:"
    | "space-around"
    | "space-between"
    | "space-evenly"
    | "spacing:"
    | "speed"
    | "speedController"
    | "spline"
    | "splines"
    | "spoke"
    | "stable"
    | "stacked:"
    | "stage"
    | "stages"
    | "standard"
    | "start"
    | "startDate:"
    | "stateInvariant:"
    | "static:"
    | "step"
    | "steps"
    | "stereotype:"
    | "stereotypes:"
    | "storageTank"
    | "straight"
    | "stress"
    | "string"
    | "strokeColor:"
    | "strokeWidth:"
    | "structure"
    | "style"
    | "style:"
    | "submachine"
    | "sunset"
    | "sw"
    | "sync"
    | "synthetic"
    | "t/h"
    | "target"
    | "team"
    | "temp:"
    | "temperature"
    | "temperatureAlarmHigh"
    | "temperatureAlarmHighHigh"
    | "temperatureAlarmLow"
    | "temperatureAlarmLowLow"
    | "temperatureController"
    | "temperatureIndicator"
    | "temperatureIndicatorController"
    | "temperatureRecorder"
    | "temperatureSwitch"
    | "temperatureTransmitter"
    | "template"
    | "templateId:"
    | "terminate"
    | "text"
    | "textAlign:"
    | "textColor:"
    | "theme"
    | "thermal"
    | "timeObservation"
    | "timeline"
    | "timing:"
    | "title:"
    | "to"
    | "to:"
    | "tooltip:"
    | "top"
    | "top-left"
    | "top-right"
    | "tran"
    | "true"
    | "turbineSteam"
    | "type"
    | "type:"
    | "unit:"
    | "units"
    | "useContainers"
    | "utility"
    | "value"
    | "value:"
    | "valveAngle"
    | "valveBall"
    | "valveButterfly"
    | "valveCheck"
    | "valveControl"
    | "valveDiaphragm"
    | "valveGate"
    | "valveGlobe"
    | "valveNeedle"
    | "valvePinch"
    | "valvePlug"
    | "valveSafetyRelief"
    | "valveShutoff"
    | "valveThreeWay"
    | "vertical"
    | "verticalAlign:"
    | "verticalAxis"
    | "verticalFork"
    | "vesselHorizontal"
    | "vesselVertical"
    | "vibrant"
    | "vibrationTransmitter"
    | "visibility:"
    | "volume:"
    | "w"
    | "wardley"
    | "warm"
    | "water-glycol"
    | "weight:"
    | "when:"
    | "xAxis"
    | "xLabel:"
    | "xor"
    | "yAxis"
    | "yLabel:"
    | "{"
    | "}";

export type RuniqTokenNames = RuniqTerminalNames | RuniqKeywordNames;

export type AccuracyUnit = '%' | 'ppm' | 'units';

export function isAccuracyUnit(item: unknown): item is AccuracyUnit {
    return item === '%' || item === 'ppm' || item === 'units';
}

export interface AffectedProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'AffectedProperty';
    value: BooleanValue;
}

export const AffectedProperty = {
    $type: 'AffectedProperty',
    value: 'value'
} as const;

export function isAffectedProperty(item: unknown): item is AffectedProperty {
    return reflection.isInstance(item, AffectedProperty.$type);
}

export type AlignContentValue = 'center' | 'left' | 'right';

export function isAlignContentValue(item: unknown): item is AlignContentValue {
    return item === 'left' || item === 'center' || item === 'right';
}

export type AnalysisKind = 'ac' | 'dc' | 'noise' | 'op' | 'tran';

export function isAnalysisKind(item: unknown): item is AnalysisKind {
    return item === 'tran' || item === 'ac' || item === 'dc' || item === 'op' || item === 'noise';
}

export interface AnalysisStatement extends langium.AstNode {
    readonly $container: ElectricalProfile;
    readonly $type: 'AnalysisStatement';
    args?: string;
    kind: AnalysisKind;
}

export const AnalysisStatement = {
    $type: 'AnalysisStatement',
    args: 'args',
    kind: 'kind'
} as const;

export function isAnalysisStatement(item: unknown): item is AnalysisStatement {
    return reflection.isInstance(item, AnalysisStatement.$type);
}

export interface ArrowTypeProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'ArrowTypeProperty';
    value: ArrowTypeValue;
}

export const ArrowTypeProperty = {
    $type: 'ArrowTypeProperty',
    value: 'value'
} as const;

export function isArrowTypeProperty(item: unknown): item is ArrowTypeProperty {
    return reflection.isInstance(item, ArrowTypeProperty.$type);
}

export type ArrowTypeValue = 'hollow' | 'none' | 'open' | 'standard';

export function isArrowTypeValue(item: unknown): item is ArrowTypeValue {
    return item === 'standard' || item === 'hollow' || item === 'open' || item === 'none';
}

export interface AttrConstraintsField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrConstraintsField';
    values: Array<string>;
}

export const AttrConstraintsField = {
    $type: 'AttrConstraintsField',
    values: 'values'
} as const;

export function isAttrConstraintsField(item: unknown): item is AttrConstraintsField {
    return reflection.isInstance(item, AttrConstraintsField.$type);
}

export interface AttrDefaultField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrDefaultField';
    value: string;
}

export const AttrDefaultField = {
    $type: 'AttrDefaultField',
    value: 'value'
} as const;

export function isAttrDefaultField(item: unknown): item is AttrDefaultField {
    return reflection.isInstance(item, AttrDefaultField.$type);
}

export interface AttrDerivedField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrDerivedField';
    value: BooleanValue;
}

export const AttrDerivedField = {
    $type: 'AttrDerivedField',
    value: 'value'
} as const;

export function isAttrDerivedField(item: unknown): item is AttrDerivedField {
    return reflection.isInstance(item, AttrDerivedField.$type);
}

export interface AttributeDecl extends langium.AstNode {
    readonly $container: AttributesProperty;
    readonly $type: 'AttributeDecl';
    properties: Array<AttributeField>;
}

export const AttributeDecl = {
    $type: 'AttributeDecl',
    properties: 'properties'
} as const;

export function isAttributeDecl(item: unknown): item is AttributeDecl {
    return reflection.isInstance(item, AttributeDecl.$type);
}

export type AttributeField = AttrConstraintsField | AttrDefaultField | AttrDerivedField | AttrNameField | AttrStaticField | AttrTypeField | AttrVisibilityField;

export const AttributeField = {
    $type: 'AttributeField'
} as const;

export function isAttributeField(item: unknown): item is AttributeField {
    return reflection.isInstance(item, AttributeField.$type);
}

export interface AttributesProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'AttributesProperty';
    attributes: Array<AttributeDecl>;
}

export const AttributesProperty = {
    $type: 'AttributesProperty',
    attributes: 'attributes'
} as const;

export function isAttributesProperty(item: unknown): item is AttributesProperty {
    return reflection.isInstance(item, AttributesProperty.$type);
}

export interface AttrNameField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrNameField';
    value: string;
}

export const AttrNameField = {
    $type: 'AttrNameField',
    value: 'value'
} as const;

export function isAttrNameField(item: unknown): item is AttrNameField {
    return reflection.isInstance(item, AttrNameField.$type);
}

export interface AttrStaticField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrStaticField';
    value: BooleanValue;
}

export const AttrStaticField = {
    $type: 'AttrStaticField',
    value: 'value'
} as const;

export function isAttrStaticField(item: unknown): item is AttrStaticField {
    return reflection.isInstance(item, AttrStaticField.$type);
}

export interface AttrTypeField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrTypeField';
    value: string;
}

export const AttrTypeField = {
    $type: 'AttrTypeField',
    value: 'value'
} as const;

export function isAttrTypeField(item: unknown): item is AttrTypeField {
    return reflection.isInstance(item, AttrTypeField.$type);
}

export interface AttrVisibilityField extends langium.AstNode {
    readonly $container: AttributeDecl;
    readonly $type: 'AttrVisibilityField';
    value: VisibilityValue;
}

export const AttrVisibilityField = {
    $type: 'AttrVisibilityField',
    value: 'value'
} as const;

export function isAttrVisibilityField(item: unknown): item is AttrVisibilityField {
    return reflection.isInstance(item, AttrVisibilityField.$type);
}

export type AutoResizeValue = 'false' | 'fill-available' | 'fit-content' | 'true';

export function isAutoResizeValue(item: unknown): item is AutoResizeValue {
    return item === 'true' || item === 'false' || item === 'fit-content' || item === 'fill-available';
}

export type BooleanValue = 'false' | 'true';

export function isBooleanValue(item: unknown): item is BooleanValue {
    return item === 'true' || item === 'false';
}

export interface BorderRadiusProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'BorderRadiusProperty';
    value: string;
}

export const BorderRadiusProperty = {
    $type: 'BorderRadiusProperty',
    value: 'value'
} as const;

export function isBorderRadiusProperty(item: unknown): item is BorderRadiusProperty {
    return reflection.isInstance(item, BorderRadiusProperty.$type);
}

export type BorderStyleValue = 'dashed' | 'dotted' | 'solid';

export function isBorderStyleValue(item: unknown): item is BorderStyleValue {
    return item === 'solid' || item === 'dashed' || item === 'dotted';
}

export interface BusWidth extends langium.AstNode {
    readonly $container: NetDecl | PortConnection | PortDecl;
    readonly $type: 'BusWidth';
    lsb: string;
    msb: string;
}

export const BusWidth = {
    $type: 'BusWidth',
    lsb: 'lsb',
    msb: 'msb'
} as const;

export function isBusWidth(item: unknown): item is BusWidth {
    return reflection.isInstance(item, BusWidth.$type);
}

export type ButtonPositionValue = 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right';

export function isButtonPositionValue(item: unknown): item is ButtonPositionValue {
    return item === 'top-left' || item === 'top-right' || item === 'bottom-left' || item === 'bottom-right';
}

export type ButtonStyleValue = 'icon' | 'icon-text' | 'text';

export function isButtonStyleValue(item: unknown): item is ButtonStyleValue {
    return item === 'icon' || item === 'text' || item === 'icon-text';
}

export interface CarrierProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'CarrierProperty';
    value: BooleanValue;
}

export const CarrierProperty = {
    $type: 'CarrierProperty',
    value: 'value'
} as const;

export function isCarrierProperty(item: unknown): item is CarrierProperty {
    return reflection.isInstance(item, CarrierProperty.$type);
}

export type CollapseEasingValue = 'easeIn' | 'easeInOut' | 'easeOut' | 'linear';

export function isCollapseEasingValue(item: unknown): item is CollapseEasingValue {
    return item === 'linear' || item === 'easeIn' || item === 'easeOut' || item === 'easeInOut';
}

export type CollapseModeValue = 'full' | 'partial';

export function isCollapseModeValue(item: unknown): item is CollapseModeValue {
    return item === 'full' || item === 'partial';
}

export type CollapseTransitionValue = 'collapsing' | 'expanding' | 'stable';

export function isCollapseTransitionValue(item: unknown): item is CollapseTransitionValue {
    return item === 'stable' || item === 'collapsing' || item === 'expanding';
}

export interface ColorsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ColorsProperty';
    value: StringArray;
}

export const ColorsProperty = {
    $type: 'ColorsProperty',
    value: 'value'
} as const;

export function isColorsProperty(item: unknown): item is ColorsProperty {
    return reflection.isInstance(item, ColorsProperty.$type);
}

export interface ConditionalBlock extends langium.AstNode {
    readonly $container: ConditionalBlock | ForEachBlock | LoopBlock;
    readonly $type: 'ConditionalBlock';
    condition: TemplateExpression;
    statements: Array<TemplateStatement>;
}

export const ConditionalBlock = {
    $type: 'ConditionalBlock',
    condition: 'condition',
    statements: 'statements'
} as const;

export function isConditionalBlock(item: unknown): item is ConditionalBlock {
    return reflection.isInstance(item, ConditionalBlock.$type);
}

export interface ConnectionPoint extends langium.AstNode {
    readonly $container: PIDLineFromProperty | PIDLineToProperty;
    readonly $type: 'ConnectionPoint';
    equipment: string;
    port?: FlexibleID;
}

export const ConnectionPoint = {
    $type: 'ConnectionPoint',
    equipment: 'equipment',
    port: 'port'
} as const;

export function isConnectionPoint(item: unknown): item is ConnectionPoint {
    return reflection.isInstance(item, ConnectionPoint.$type);
}

export interface ContainerBlock extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'ContainerBlock';
    id?: FlexibleID;
    label: string;
    properties: Array<ContainerProperty>;
    shape?: FlexibleID | string;
    statements: Array<DiagramStatement>;
}

export const ContainerBlock = {
    $type: 'ContainerBlock',
    id: 'id',
    label: 'label',
    properties: 'properties',
    shape: 'shape',
    statements: 'statements'
} as const;

export function isContainerBlock(item: unknown): item is ContainerBlock {
    return reflection.isInstance(item, ContainerBlock.$type);
}

export interface ContainerLayoutProperty extends langium.AstNode {
    readonly $container: ContainerBlock;
    readonly $type: 'ContainerLayoutProperty';
    algorithm?: LayoutAlgorithmValue;
    direction?: DirectionValue;
    orientation?: OrientationValue;
    spacing?: string;
}

export const ContainerLayoutProperty = {
    $type: 'ContainerLayoutProperty',
    algorithm: 'algorithm',
    direction: 'direction',
    orientation: 'orientation',
    spacing: 'spacing'
} as const;

export function isContainerLayoutProperty(item: unknown): item is ContainerLayoutProperty {
    return reflection.isInstance(item, ContainerLayoutProperty.$type);
}

export interface ContainerMetadataProperty extends langium.AstNode {
    readonly $container: ContainerBlock;
    readonly $type: 'ContainerMetadataProperty';
    badge?: string;
    collapseAnimationDuration?: string;
    collapseAnimationEasing?: CollapseEasingValue;
    collapsed?: BooleanValue;
    collapseIcon?: string;
    collapseKeyboardShortcut?: string;
    collapseMode?: CollapseModeValue;
    collapsePersistState?: BooleanValue;
    collapseRedirectEdges?: BooleanValue;
    collapseShowCount?: BooleanValue;
    collapseStateKey?: string;
    collapseSummary?: string;
    collapseTransitionState?: CollapseTransitionValue;
    collapsible?: BooleanValue;
    header?: string;
    icon?: string;
}

export const ContainerMetadataProperty = {
    $type: 'ContainerMetadataProperty',
    badge: 'badge',
    collapseAnimationDuration: 'collapseAnimationDuration',
    collapseAnimationEasing: 'collapseAnimationEasing',
    collapsed: 'collapsed',
    collapseIcon: 'collapseIcon',
    collapseKeyboardShortcut: 'collapseKeyboardShortcut',
    collapseMode: 'collapseMode',
    collapsePersistState: 'collapsePersistState',
    collapseRedirectEdges: 'collapseRedirectEdges',
    collapseShowCount: 'collapseShowCount',
    collapseStateKey: 'collapseStateKey',
    collapseSummary: 'collapseSummary',
    collapseTransitionState: 'collapseTransitionState',
    collapsible: 'collapsible',
    header: 'header',
    icon: 'icon'
} as const;

export function isContainerMetadataProperty(item: unknown): item is ContainerMetadataProperty {
    return reflection.isInstance(item, ContainerMetadataProperty.$type);
}

export type ContainerProperty = ContainerLayoutProperty | ContainerMetadataProperty | ContainerStyleProperty | ContainerTypeProperty | StyleRefProperty;

export const ContainerProperty = {
    $type: 'ContainerProperty'
} as const;

export function isContainerProperty(item: unknown): item is ContainerProperty {
    return reflection.isInstance(item, ContainerProperty.$type);
}

export interface ContainerStyleProperty extends langium.AstNode {
    readonly $container: ContainerBlock | PresetBlock | TemplateBlock;
    readonly $type: 'ContainerStyleProperty';
    alignContent?: AlignContentValue;
    autoResize?: AutoResizeValue;
    borderStyle?: BorderStyleValue;
    childCountPosition?: ButtonPositionValue;
    collapseButtonColor?: string;
    collapseButtonPosition?: ButtonPositionValue;
    collapseButtonSize?: string;
    collapseButtonStyle?: ButtonStyleValue;
    collapseButtonVisible?: BooleanValue;
    crossContainerEdgeOptimization?: BooleanValue;
    depth?: string;
    depthIndicatorStyle?: DepthIndicatorStyleValue;
    distribution?: DistributionValue;
    edgeBundling?: BooleanValue;
    edgeRouting?: EdgeRoutingValue;
    extends?: string;
    fillColor?: string;
    headerBackgroundColor?: string;
    headerPosition?: LabelPositionValue;
    hoverBorderColor?: string;
    hoverBorderWidth?: string;
    hoverHighlight?: BooleanValue;
    iconColor?: string;
    iconSize?: string;
    incrementalLayout?: BooleanValue;
    labelPosition?: LabelPositionValue;
    layoutCache?: BooleanValue;
    layoutComplexity?: LayoutComplexityValue;
    margin?: string;
    marginBottom?: string;
    marginLeft?: string;
    marginRight?: string;
    marginTop?: string;
    maxHeight?: string;
    maxWidth?: string;
    minHeight?: string;
    minResizeHeight?: string;
    minResizeWidth?: string;
    minWidth?: string;
    nodeSpacing?: string;
    opacity?: string;
    padding?: string;
    paddingBottom?: string;
    paddingLeft?: string;
    paddingRight?: string;
    paddingTop?: string;
    preset?: string;
    resizable?: BooleanValue;
    resizeHandles: Array<ResizeHandleValue>;
    selectionBorderColor?: string;
    selectionBorderWidth?: string;
    selectionHighlight?: BooleanValue;
    shadow?: BooleanValue;
    showChildCount?: BooleanValue;
    showDepthIndicator?: BooleanValue;
    strokeColor?: string;
    strokeWidth?: string;
    templateId?: string;
    verticalAlign?: VerticalAlignValue;
}

export const ContainerStyleProperty = {
    $type: 'ContainerStyleProperty',
    alignContent: 'alignContent',
    autoResize: 'autoResize',
    borderStyle: 'borderStyle',
    childCountPosition: 'childCountPosition',
    collapseButtonColor: 'collapseButtonColor',
    collapseButtonPosition: 'collapseButtonPosition',
    collapseButtonSize: 'collapseButtonSize',
    collapseButtonStyle: 'collapseButtonStyle',
    collapseButtonVisible: 'collapseButtonVisible',
    crossContainerEdgeOptimization: 'crossContainerEdgeOptimization',
    depth: 'depth',
    depthIndicatorStyle: 'depthIndicatorStyle',
    distribution: 'distribution',
    edgeBundling: 'edgeBundling',
    edgeRouting: 'edgeRouting',
    extends: 'extends',
    fillColor: 'fillColor',
    headerBackgroundColor: 'headerBackgroundColor',
    headerPosition: 'headerPosition',
    hoverBorderColor: 'hoverBorderColor',
    hoverBorderWidth: 'hoverBorderWidth',
    hoverHighlight: 'hoverHighlight',
    iconColor: 'iconColor',
    iconSize: 'iconSize',
    incrementalLayout: 'incrementalLayout',
    labelPosition: 'labelPosition',
    layoutCache: 'layoutCache',
    layoutComplexity: 'layoutComplexity',
    margin: 'margin',
    marginBottom: 'marginBottom',
    marginLeft: 'marginLeft',
    marginRight: 'marginRight',
    marginTop: 'marginTop',
    maxHeight: 'maxHeight',
    maxWidth: 'maxWidth',
    minHeight: 'minHeight',
    minResizeHeight: 'minResizeHeight',
    minResizeWidth: 'minResizeWidth',
    minWidth: 'minWidth',
    nodeSpacing: 'nodeSpacing',
    opacity: 'opacity',
    padding: 'padding',
    paddingBottom: 'paddingBottom',
    paddingLeft: 'paddingLeft',
    paddingRight: 'paddingRight',
    paddingTop: 'paddingTop',
    preset: 'preset',
    resizable: 'resizable',
    resizeHandles: 'resizeHandles',
    selectionBorderColor: 'selectionBorderColor',
    selectionBorderWidth: 'selectionBorderWidth',
    selectionHighlight: 'selectionHighlight',
    shadow: 'shadow',
    showChildCount: 'showChildCount',
    showDepthIndicator: 'showDepthIndicator',
    strokeColor: 'strokeColor',
    strokeWidth: 'strokeWidth',
    templateId: 'templateId',
    verticalAlign: 'verticalAlign'
} as const;

export function isContainerStyleProperty(item: unknown): item is ContainerStyleProperty {
    return reflection.isInstance(item, ContainerStyleProperty.$type);
}

export interface ContainerTypeProperty extends langium.AstNode {
    readonly $container: ContainerBlock;
    readonly $type: 'ContainerTypeProperty';
    type: ContainerTypeValue;
}

export const ContainerTypeProperty = {
    $type: 'ContainerTypeProperty',
    type: 'type'
} as const;

export function isContainerTypeProperty(item: unknown): item is ContainerTypeProperty {
    return reflection.isInstance(item, ContainerTypeProperty.$type);
}

export type ContainerTypeValue = 'mindmap' | string;

export function isContainerTypeValue(item: unknown): item is ContainerTypeValue {
    return item === 'mindmap' || (typeof item === 'string' && (/[a-zA-Z_][a-zA-Z0-9_]*/.test(item)));
}

export type ControlMode = 'auto' | 'cascade' | 'feedforward' | 'manual' | 'ratio';

export function isControlMode(item: unknown): item is ControlMode {
    return item === 'manual' || item === 'auto' || item === 'cascade' || item === 'ratio' || item === 'feedforward';
}

export type ControlVariable = 'composition' | 'conductivity' | 'flow' | 'level' | 'ph' | 'pressure' | 'speed' | 'temperature';

export function isControlVariable(item: unknown): item is ControlVariable {
    return item === 'flow' || item === 'temperature' || item === 'pressure' || item === 'level' || item === 'composition' || item === 'ph' || item === 'conductivity' || item === 'speed';
}

export interface DataArray extends langium.AstNode {
    readonly $container: DataObjectProperty;
    readonly $type: 'DataArray';
    items: Array<string>;
}

export const DataArray = {
    $type: 'DataArray',
    items: 'items'
} as const;

export function isDataArray(item: unknown): item is DataArray {
    return reflection.isInstance(item, DataArray.$type);
}

export type DataItem = DataObject | DataValue;

export const DataItem = {
    $type: 'DataItem'
} as const;

export function isDataItem(item: unknown): item is DataItem {
    return reflection.isInstance(item, DataItem.$type);
}

export interface DataObject extends langium.AstNode {
    readonly $container: DataProperty;
    readonly $type: 'DataObject';
    properties: Array<DataObjectProperty>;
}

export const DataObject = {
    $type: 'DataObject',
    properties: 'properties'
} as const;

export function isDataObject(item: unknown): item is DataObject {
    return reflection.isInstance(item, DataObject.$type);
}

export interface DataObjectProperty extends langium.AstNode {
    readonly $container: DataObject;
    readonly $type: 'DataObjectProperty';
    key: string;
    value: DataArray | string;
}

export const DataObjectProperty = {
    $type: 'DataObjectProperty',
    key: 'key',
    value: 'value'
} as const;

export function isDataObjectProperty(item: unknown): item is DataObjectProperty {
    return reflection.isInstance(item, DataObjectProperty.$type);
}

export interface DataProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'DataProperty';
    items: Array<DataItem>;
}

export const DataProperty = {
    $type: 'DataProperty',
    items: 'items'
} as const;

export function isDataProperty(item: unknown): item is DataProperty {
    return reflection.isInstance(item, DataProperty.$type);
}

export interface DataSourceDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'DataSourceDeclaration';
    format: string;
    key: string;
    options: Array<DataSourceOption>;
    source: string;
}

export const DataSourceDeclaration = {
    $type: 'DataSourceDeclaration',
    format: 'format',
    key: 'key',
    options: 'options',
    source: 'source'
} as const;

export function isDataSourceDeclaration(item: unknown): item is DataSourceDeclaration {
    return reflection.isInstance(item, DataSourceDeclaration.$type);
}

export interface DataSourceOption extends langium.AstNode {
    readonly $container: DataSourceDeclaration;
    readonly $type: 'DataSourceOption';
    name: string;
    value: BooleanValue | string;
}

export const DataSourceOption = {
    $type: 'DataSourceOption',
    name: 'name',
    value: 'value'
} as const;

export function isDataSourceOption(item: unknown): item is DataSourceOption {
    return reflection.isInstance(item, DataSourceOption.$type);
}

export interface DataValue extends langium.AstNode {
    readonly $container: DataProperty;
    readonly $type: 'DataValue';
    value: string;
}

export const DataValue = {
    $type: 'DataValue',
    value: 'value'
} as const;

export function isDataValue(item: unknown): item is DataValue {
    return reflection.isInstance(item, DataValue.$type);
}

export interface DeceasedProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'DeceasedProperty';
    value: BooleanValue;
}

export const DeceasedProperty = {
    $type: 'DeceasedProperty',
    value: 'value'
} as const;

export function isDeceasedProperty(item: unknown): item is DeceasedProperty {
    return reflection.isInstance(item, DeceasedProperty.$type);
}

export type DepthIndicatorStyleValue = 'bar' | 'color' | 'indent';

export function isDepthIndicatorStyleValue(item: unknown): item is DepthIndicatorStyleValue {
    return item === 'bar' || item === 'indent' || item === 'color';
}

export interface DiagramProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'DiagramProfile';
    name: string;
    statements: Array<DiagramStatement>;
}

export const DiagramProfile = {
    $type: 'DiagramProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isDiagramProfile(item: unknown): item is DiagramProfile {
    return reflection.isInstance(item, DiagramProfile.$type);
}

export type DiagramStatement = ContainerBlock | DataSourceDeclaration | DirectionDeclaration | EdgeDeclaration | ForEachBlock | GroupBlock | PresetBlock | RoutingDeclaration | ShapeDeclaration | StyleDeclaration | TemplateBlock | ThemeDeclaration;

export const DiagramStatement = {
    $type: 'DiagramStatement'
} as const;

export function isDiagramStatement(item: unknown): item is DiagramStatement {
    return reflection.isInstance(item, DiagramStatement.$type);
}

export interface DigitalNetStatement extends langium.AstNode {
    readonly $container: DigitalProfile;
    readonly $type: 'DigitalNetStatement';
    names: Array<NetDecl>;
}

export const DigitalNetStatement = {
    $type: 'DigitalNetStatement',
    names: 'names'
} as const;

export function isDigitalNetStatement(item: unknown): item is DigitalNetStatement {
    return reflection.isInstance(item, DigitalNetStatement.$type);
}

export interface DigitalProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'DigitalProfile';
    name: string;
    statements: Array<DigitalStatement>;
}

export const DigitalProfile = {
    $type: 'DigitalProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isDigitalProfile(item: unknown): item is DigitalProfile {
    return reflection.isInstance(item, DigitalProfile.$type);
}

export type DigitalStatement = DigitalNetStatement | InstStatement | ModuleStatement;

export const DigitalStatement = {
    $type: 'DigitalStatement'
} as const;

export function isDigitalStatement(item: unknown): item is DigitalStatement {
    return reflection.isInstance(item, DigitalStatement.$type);
}

export type DimensionUnit = 'cm' | 'ft' | 'in' | 'm' | 'mm';

export function isDimensionUnit(item: unknown): item is DimensionUnit {
    return item === 'mm' || item === 'cm' || item === 'm' || item === 'in' || item === 'ft';
}

export interface DirectionDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'DirectionDeclaration';
    value: DirectionValue;
}

export const DirectionDeclaration = {
    $type: 'DirectionDeclaration',
    value: 'value'
} as const;

export function isDirectionDeclaration(item: unknown): item is DirectionDeclaration {
    return reflection.isInstance(item, DirectionDeclaration.$type);
}

export type DirectionValue = 'BT' | 'LR' | 'RL' | 'TB';

export function isDirectionValue(item: unknown): item is DirectionValue {
    return item === 'LR' || item === 'RL' || item === 'TB' || item === 'BT';
}

export type DistributionValue = 'packed' | 'space-around' | 'space-between' | 'space-evenly';

export function isDistributionValue(item: unknown): item is DistributionValue {
    return item === 'space-evenly' || item === 'space-between' || item === 'space-around' || item === 'packed';
}

export interface DoActivityProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'DoActivityProperty';
    value: string;
}

export const DoActivityProperty = {
    $type: 'DoActivityProperty',
    value: 'value'
} as const;

export function isDoActivityProperty(item: unknown): item is DoActivityProperty {
    return reflection.isInstance(item, DoActivityProperty.$type);
}

export interface Document extends langium.AstNode {
    readonly $type: 'Document';
    profiles: Array<Profile>;
}

export const Document = {
    $type: 'Document',
    profiles: 'profiles'
} as const;

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document.$type);
}

export interface EdgeChain extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EdgeChain';
    anchoredArrow?: string;
    arrow?: string;
    bidirectionalArrow?: string;
    labeledArrow?: string;
    to: NodeRef;
}

export const EdgeChain = {
    $type: 'EdgeChain',
    anchoredArrow: 'anchoredArrow',
    arrow: 'arrow',
    bidirectionalArrow: 'bidirectionalArrow',
    labeledArrow: 'labeledArrow',
    to: 'to'
} as const;

export function isEdgeChain(item: unknown): item is EdgeChain {
    return reflection.isInstance(item, EdgeChain.$type);
}

export interface EdgeConstraintsProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EdgeConstraintsProperty';
    values: Array<string>;
}

export const EdgeConstraintsProperty = {
    $type: 'EdgeConstraintsProperty',
    values: 'values'
} as const;

export function isEdgeConstraintsProperty(item: unknown): item is EdgeConstraintsProperty {
    return reflection.isInstance(item, EdgeConstraintsProperty.$type);
}

export interface EdgeDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'EdgeDeclaration';
    anchoredArrow?: string;
    arrow?: string;
    bidirectionalArrow?: string;
    chain: Array<EdgeChain>;
    from: NodeRef;
    labeledArrow?: string;
    properties: Array<EdgeProperty>;
    to: NodeRef;
}

export const EdgeDeclaration = {
    $type: 'EdgeDeclaration',
    anchoredArrow: 'anchoredArrow',
    arrow: 'arrow',
    bidirectionalArrow: 'bidirectionalArrow',
    chain: 'chain',
    from: 'from',
    labeledArrow: 'labeledArrow',
    properties: 'properties',
    to: 'to'
} as const;

export function isEdgeDeclaration(item: unknown): item is EdgeDeclaration {
    return reflection.isInstance(item, EdgeDeclaration.$type);
}

export interface EdgeLabelProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EdgeLabelProperty';
    label: string;
}

export const EdgeLabelProperty = {
    $type: 'EdgeLabelProperty',
    label: 'label'
} as const;

export function isEdgeLabelProperty(item: unknown): item is EdgeLabelProperty {
    return reflection.isInstance(item, EdgeLabelProperty.$type);
}

export type EdgeProperty = ArrowTypeProperty | EdgeConstraintsProperty | EdgeLabelProperty | EdgeTypeProperty | EffectProperty | EventProperty | FlowTypeProperty | GuardProperty | LineStyleProperty | MultiplicitySourceProperty | MultiplicityTargetProperty | NavigabilityProperty | RoleSourceProperty | RoleTargetProperty | RoutingProperty | StereotypeProperty | StrokeColorProperty | StrokeWidthProperty | StyleRefProperty | WeightProperty;

export const EdgeProperty = {
    $type: 'EdgeProperty'
} as const;

export function isEdgeProperty(item: unknown): item is EdgeProperty {
    return reflection.isInstance(item, EdgeProperty.$type);
}

export type EdgeRoutingValue = 'container-aware' | 'orthogonal' | 'polyline' | 'spline';

export function isEdgeRoutingValue(item: unknown): item is EdgeRoutingValue {
    return item === 'container-aware' || item === 'orthogonal' || item === 'spline' || item === 'polyline';
}

export interface EdgeTypeProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EdgeTypeProperty';
    value: EdgeTypeValue;
}

export const EdgeTypeProperty = {
    $type: 'EdgeTypeProperty',
    value: 'value'
} as const;

export function isEdgeTypeProperty(item: unknown): item is EdgeTypeProperty {
    return reflection.isInstance(item, EdgeTypeProperty.$type);
}

export type EdgeTypeValue = 'aggregation' | 'association' | 'composition' | 'dependency' | 'generalization' | 'realization';

export function isEdgeTypeValue(item: unknown): item is EdgeTypeValue {
    return item === 'association' || item === 'aggregation' || item === 'composition' || item === 'dependency' || item === 'generalization' || item === 'realization';
}

export interface EffectProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EffectProperty';
    value: string;
}

export const EffectProperty = {
    $type: 'EffectProperty',
    value: 'value'
} as const;

export function isEffectProperty(item: unknown): item is EffectProperty {
    return reflection.isInstance(item, EffectProperty.$type);
}

export interface ElectricalProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'ElectricalProfile';
    name: string;
    statements: Array<ElectricalStatement>;
}

export const ElectricalProfile = {
    $type: 'ElectricalProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isElectricalProfile(item: unknown): item is ElectricalProfile {
    return reflection.isInstance(item, ElectricalProfile.$type);
}

export type ElectricalStatement = AnalysisStatement | NetStatement | PartStatement;

export const ElectricalStatement = {
    $type: 'ElectricalStatement'
} as const;

export function isElectricalStatement(item: unknown): item is ElectricalStatement {
    return reflection.isInstance(item, ElectricalStatement.$type);
}

export interface EntryProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'EntryProperty';
    value: string;
}

export const EntryProperty = {
    $type: 'EntryProperty',
    value: 'value'
} as const;

export function isEntryProperty(item: unknown): item is EntryProperty {
    return reflection.isInstance(item, EntryProperty.$type);
}

export interface EventProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'EventProperty';
    value: string;
}

export const EventProperty = {
    $type: 'EventProperty',
    value: 'value'
} as const;

export function isEventProperty(item: unknown): item is EventProperty {
    return reflection.isInstance(item, EventProperty.$type);
}

export interface ExitProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ExitProperty';
    value: string;
}

export const ExitProperty = {
    $type: 'ExitProperty',
    value: 'value'
} as const;

export function isExitProperty(item: unknown): item is ExitProperty {
    return reflection.isInstance(item, ExitProperty.$type);
}

export interface ExtensionPointsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ExtensionPointsProperty';
    value: StringArray;
}

export const ExtensionPointsProperty = {
    $type: 'ExtensionPointsProperty',
    value: 'value'
} as const;

export function isExtensionPointsProperty(item: unknown): item is ExtensionPointsProperty {
    return reflection.isInstance(item, ExtensionPointsProperty.$type);
}

export interface FillColorProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'FillColorProperty';
    value: string;
}

export const FillColorProperty = {
    $type: 'FillColorProperty',
    value: 'value'
} as const;

export function isFillColorProperty(item: unknown): item is FillColorProperty {
    return reflection.isInstance(item, FillColorProperty.$type);
}

export type FlexibleID = 'action' | 'api' | 'branch' | 'cache' | 'call' | 'center' | 'central' | 'child' | 'color' | 'composition' | 'conductivity' | 'config' | 'data' | 'db' | 'delimiter' | 'detail' | 'done' | 'end' | 'f' | 'filter' | 'flow' | 'for' | 'format' | 'from' | 'header' | 'hub' | 'id' | 'if' | 'in' | 'input' | 'key' | 'label' | 'leader' | 'leaf' | 'left' | 'level' | 'limit' | 'loop' | 'm' | 'member' | 'mobile' | 'name' | 'node' | 'output' | 'ph' | 'pressure' | 'process' | 'queue' | 'right' | 'root' | 'settings' | 'source' | 'speed' | 'spoke' | 'start' | 'step' | 'team' | 'temperature' | 'to' | 'type' | 'value' | string;

export function isFlexibleID(item: unknown): item is FlexibleID {
    return item === 'data' || item === 'from' || item === 'to' || item === 'key' || item === 'source' || item === 'filter' || item === 'limit' || item === 'label' || item === 'name' || item === 'id' || item === 'type' || item === 'value' || item === 'format' || item === 'color' || item === 'header' || item === 'delimiter' || item === 'for' || item === 'in' || item === 'if' || item === 'loop' || item === 'call' || item === 'start' || item === 'end' || item === 'done' || item === 'process' || item === 'mobile' || item === 'm' || item === 'f' || item === 'step' || item === 'action' || item === 'input' || item === 'output' || item === 'config' || item === 'settings' || item === 'api' || item === 'db' || item === 'cache' || item === 'queue' || item === 'root' || item === 'child' || item === 'branch' || item === 'leaf' || item === 'node' || item === 'center' || item === 'central' || item === 'hub' || item === 'left' || item === 'right' || item === 'team' || item === 'leader' || item === 'member' || item === 'detail' || item === 'spoke' || item === 'flow' || item === 'temperature' || item === 'pressure' || item === 'level' || item === 'composition' || item === 'ph' || item === 'conductivity' || item === 'speed' || (typeof item === 'string' && (/[a-zA-Z_][a-zA-Z0-9_]*/.test(item)));
}

export interface FlipAxesProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'FlipAxesProperty';
    value: BooleanValue;
}

export const FlipAxesProperty = {
    $type: 'FlipAxesProperty',
    value: 'value'
} as const;

export function isFlipAxesProperty(item: unknown): item is FlipAxesProperty {
    return reflection.isInstance(item, FlipAxesProperty.$type);
}

export interface FlowRateStatement extends langium.AstNode {
    readonly $container: HydraulicProfile | PIDProfile | PneumaticProfile;
    readonly $type: 'FlowRateStatement';
    unit: FlowRateUnit;
    value: string;
}

export const FlowRateStatement = {
    $type: 'FlowRateStatement',
    unit: 'unit',
    value: 'value'
} as const;

export function isFlowRateStatement(item: unknown): item is FlowRateStatement {
    return reflection.isInstance(item, FlowRateStatement.$type);
}

export type FlowRateUnit = 'CFM' | 'GPM' | 'L/min' | 'L/s' | 'bbl/day' | 'gal/min' | 'kg/h' | 'm³/h' | 't/h';

export function isFlowRateUnit(item: unknown): item is FlowRateUnit {
    return item === 'kg/h' || item === 't/h' || item === 'L/min' || item === 'L/s' || item === 'm³/h' || item === 'CFM' || item === 'GPM' || item === 'gal/min' || item === 'bbl/day';
}

export interface FlowTypeProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'FlowTypeProperty';
    value: string;
}

export const FlowTypeProperty = {
    $type: 'FlowTypeProperty',
    value: 'value'
} as const;

export function isFlowTypeProperty(item: unknown): item is FlowTypeProperty {
    return reflection.isInstance(item, FlowTypeProperty.$type);
}

export interface FluidStatement extends langium.AstNode {
    readonly $container: HydraulicProfile | PIDProfile;
    readonly $type: 'FluidStatement';
    maxTemp?: string;
    minTemp?: string;
    tempUnit?: TempUnit;
    type: FluidType;
    viscosity?: string;
}

export const FluidStatement = {
    $type: 'FluidStatement',
    maxTemp: 'maxTemp',
    minTemp: 'minTemp',
    tempUnit: 'tempUnit',
    type: 'type',
    viscosity: 'viscosity'
} as const;

export function isFluidStatement(item: unknown): item is FluidStatement {
    return reflection.isInstance(item, FluidStatement.$type);
}

export type FluidType = 'biodegradable' | 'mineral' | 'phosphate-ester' | 'synthetic' | 'water-glycol';

export function isFluidType(item: unknown): item is FluidType {
    return item === 'mineral' || item === 'synthetic' || item === 'biodegradable' || item === 'water-glycol' || item === 'phosphate-ester';
}

export interface FontFamilyProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'FontFamilyProperty';
    value: string;
}

export const FontFamilyProperty = {
    $type: 'FontFamilyProperty',
    value: 'value'
} as const;

export function isFontFamilyProperty(item: unknown): item is FontFamilyProperty {
    return reflection.isInstance(item, FontFamilyProperty.$type);
}

export interface FontSizeProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'FontSizeProperty';
    value: string;
}

export const FontSizeProperty = {
    $type: 'FontSizeProperty',
    value: 'value'
} as const;

export function isFontSizeProperty(item: unknown): item is FontSizeProperty {
    return reflection.isInstance(item, FontSizeProperty.$type);
}

export interface FontWeightProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'FontWeightProperty';
    value: string;
}

export const FontWeightProperty = {
    $type: 'FontWeightProperty',
    value: 'value'
} as const;

export function isFontWeightProperty(item: unknown): item is FontWeightProperty {
    return reflection.isInstance(item, FontWeightProperty.$type);
}

export interface ForEachBlock extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'ForEachBlock';
    dataKey: string;
    filter?: string;
    id: string;
    limit?: string;
    statements: Array<TemplateStatement>;
}

export const ForEachBlock = {
    $type: 'ForEachBlock',
    dataKey: 'dataKey',
    filter: 'filter',
    id: 'id',
    limit: 'limit',
    statements: 'statements'
} as const;

export function isForEachBlock(item: unknown): item is ForEachBlock {
    return reflection.isInstance(item, ForEachBlock.$type);
}

export interface GatewayTypeProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'GatewayTypeProperty';
    value: GatewayTypeValue;
}

export const GatewayTypeProperty = {
    $type: 'GatewayTypeProperty',
    value: 'value'
} as const;

export function isGatewayTypeProperty(item: unknown): item is GatewayTypeProperty {
    return reflection.isInstance(item, GatewayTypeProperty.$type);
}

export type GatewayTypeValue = 'and' | 'complex' | 'event' | 'eventBased' | 'exclusive' | 'inclusive' | 'or' | 'parallel' | 'xor';

export function isGatewayTypeValue(item: unknown): item is GatewayTypeValue {
    return item === 'exclusive' || item === 'xor' || item === 'parallel' || item === 'and' || item === 'inclusive' || item === 'or' || item === 'eventBased' || item === 'event' || item === 'complex';
}

export interface GenericPIDProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement | PIDInstrumentStatement | PIDLineStatement | PIDLoopStatement;
    readonly $type: 'GenericPIDProperty';
    key: string;
    value: string;
}

export const GenericPIDProperty = {
    $type: 'GenericPIDProperty',
    key: 'key',
    value: 'value'
} as const;

export function isGenericPIDProperty(item: unknown): item is GenericPIDProperty {
    return reflection.isInstance(item, GenericPIDProperty.$type);
}

export interface GenericTypesProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'GenericTypesProperty';
    types: Array<string>;
}

export const GenericTypesProperty = {
    $type: 'GenericTypesProperty',
    types: 'types'
} as const;

export function isGenericTypesProperty(item: unknown): item is GenericTypesProperty {
    return reflection.isInstance(item, GenericTypesProperty.$type);
}

export interface GlyphSetImageItem extends langium.AstNode {
    readonly $container: GlyphSetNestedItem | GlyphSetProfile;
    readonly $type: 'GlyphSetImageItem';
    description?: string;
    keyword: 'image';
    label?: string;
    url: string;
}

export const GlyphSetImageItem = {
    $type: 'GlyphSetImageItem',
    description: 'description',
    keyword: 'keyword',
    label: 'label',
    url: 'url'
} as const;

export function isGlyphSetImageItem(item: unknown): item is GlyphSetImageItem {
    return reflection.isInstance(item, GlyphSetImageItem.$type);
}

export type GlyphSetItemStatement = GlyphSetImageItem | GlyphSetNestedItem | GlyphSetSimpleItem;

export const GlyphSetItemStatement = {
    $type: 'GlyphSetItemStatement'
} as const;

export function isGlyphSetItemStatement(item: unknown): item is GlyphSetItemStatement {
    return reflection.isInstance(item, GlyphSetItemStatement.$type);
}

export type GlyphSetKeyword = 'callout' | 'center' | 'child' | 'circle' | 'event' | 'group' | 'input' | 'item' | 'leader' | 'left' | 'level' | 'member' | 'node' | 'output' | 'person' | 'quadrant' | 'right' | 'root' | 'side' | 'spoke' | 'stage' | 'step' | 'team';

export function isGlyphSetKeyword(item: unknown): item is GlyphSetKeyword {
    return item === 'step' || item === 'item' || item === 'person' || item === 'level' || item === 'stage' || item === 'event' || item === 'quadrant' || item === 'circle' || item === 'node' || item === 'group' || item === 'side' || item === 'left' || item === 'right' || item === 'input' || item === 'output' || item === 'center' || item === 'spoke' || item === 'team' || item === 'root' || item === 'child' || item === 'leader' || item === 'member' || item === 'callout';
}

export interface GlyphSetNestedItem extends langium.AstNode {
    readonly $container: GlyphSetNestedItem | GlyphSetProfile;
    readonly $type: 'GlyphSetNestedItem';
    children: Array<GlyphSetItemStatement>;
    keyword: GlyphSetKeyword;
    label: string;
    relationship?: string;
}

export const GlyphSetNestedItem = {
    $type: 'GlyphSetNestedItem',
    children: 'children',
    keyword: 'keyword',
    label: 'label',
    relationship: 'relationship'
} as const;

export function isGlyphSetNestedItem(item: unknown): item is GlyphSetNestedItem {
    return reflection.isInstance(item, GlyphSetNestedItem.$type);
}

export interface GlyphSetParameter extends langium.AstNode {
    readonly $container: GlyphSetProfile;
    readonly $type: 'GlyphSetParameter';
    name: GlyphSetParameterName;
    value: GlyphSetParameterValue;
}

export const GlyphSetParameter = {
    $type: 'GlyphSetParameter',
    name: 'name',
    value: 'value'
} as const;

export function isGlyphSetParameter(item: unknown): item is GlyphSetParameter {
    return reflection.isInstance(item, GlyphSetParameter.$type);
}

export type GlyphSetParameterName = 'alternating' | 'bidirectional' | 'callouts' | 'center' | 'centerLabel' | 'circles' | 'colorScheme' | 'columnHeaders' | 'columns' | 'direction' | 'events' | 'frameStyle' | 'groups' | 'horizontalAxis' | 'image' | 'images' | 'items' | 'layout' | 'leftWeight' | 'levels' | 'mergePoint' | 'operator' | 'orientation' | 'overlap' | 'quadrants' | 'relationship' | 'result' | 'rightWeight' | 'rowHeaders' | 'segments' | 'shape' | 'showAllConnections' | 'showConnections' | 'showDottedLines' | 'showPercentages' | 'showValues' | 'sides' | 'source' | 'stages' | 'steps' | 'structure' | 'target' | 'theme' | 'useContainers' | 'verticalAxis' | 'xAxis' | 'yAxis';

export function isGlyphSetParameterName(item: unknown): item is GlyphSetParameterName {
    return item === 'alternating' || item === 'bidirectional' || item === 'callouts' || item === 'center' || item === 'centerLabel' || item === 'circles' || item === 'colorScheme' || item === 'columnHeaders' || item === 'columns' || item === 'direction' || item === 'events' || item === 'frameStyle' || item === 'groups' || item === 'horizontalAxis' || item === 'image' || item === 'images' || item === 'items' || item === 'layout' || item === 'leftWeight' || item === 'levels' || item === 'mergePoint' || item === 'operator' || item === 'orientation' || item === 'overlap' || item === 'quadrants' || item === 'relationship' || item === 'result' || item === 'rightWeight' || item === 'rowHeaders' || item === 'segments' || item === 'shape' || item === 'showAllConnections' || item === 'showConnections' || item === 'showDottedLines' || item === 'showPercentages' || item === 'showValues' || item === 'sides' || item === 'source' || item === 'stages' || item === 'steps' || item === 'structure' || item === 'target' || item === 'theme' || item === 'useContainers' || item === 'verticalAxis' || item === 'xAxis' || item === 'yAxis';
}

export interface GlyphSetParameterValue extends langium.AstNode {
    readonly $container: GlyphSetParameter;
    readonly $type: 'GlyphSetParameterValue';
    boolValue?: BooleanValue;
    directionValue?: DirectionValue;
    numberValue?: string;
    stringValue?: string;
    themeValue?: ThemeValue;
}

export const GlyphSetParameterValue = {
    $type: 'GlyphSetParameterValue',
    boolValue: 'boolValue',
    directionValue: 'directionValue',
    numberValue: 'numberValue',
    stringValue: 'stringValue',
    themeValue: 'themeValue'
} as const;

export function isGlyphSetParameterValue(item: unknown): item is GlyphSetParameterValue {
    return reflection.isInstance(item, GlyphSetParameterValue.$type);
}

export interface GlyphSetProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'GlyphSetProfile';
    glyphsetType: GlyphSetType;
    items: Array<GlyphSetItemStatement | GlyphSetParameter>;
    name: string;
}

export const GlyphSetProfile = {
    $type: 'GlyphSetProfile',
    glyphsetType: 'glyphsetType',
    items: 'items',
    name: 'name'
} as const;

export function isGlyphSetProfile(item: unknown): item is GlyphSetProfile {
    return reflection.isInstance(item, GlyphSetProfile.$type);
}

export interface GlyphSetSimpleItem extends langium.AstNode {
    readonly $container: GlyphSetNestedItem | GlyphSetProfile;
    readonly $type: 'GlyphSetSimpleItem';
    keyword: GlyphSetKeyword;
    label: string;
    relationship?: string;
}

export const GlyphSetSimpleItem = {
    $type: 'GlyphSetSimpleItem',
    keyword: 'keyword',
    label: 'label',
    relationship: 'relationship'
} as const;

export function isGlyphSetSimpleItem(item: unknown): item is GlyphSetSimpleItem {
    return reflection.isInstance(item, GlyphSetSimpleItem.$type);
}

export type GlyphSetType = 'balance' | 'events' | 'source' | 'target' | FlexibleID;

export function isGlyphSetType(item: unknown): item is GlyphSetType {
    return isFlexibleID(item) || item === 'target' || item === 'source' || item === 'balance' || item === 'events';
}

export interface GroupBlock extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'GroupBlock';
    label: string;
    statements: Array<DiagramStatement>;
}

export const GroupBlock = {
    $type: 'GroupBlock',
    label: 'label',
    statements: 'statements'
} as const;

export function isGroupBlock(item: unknown): item is GroupBlock {
    return reflection.isInstance(item, GroupBlock.$type);
}

export interface GuardProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'GuardProperty';
    value: string;
}

export const GuardProperty = {
    $type: 'GuardProperty',
    value: 'value'
} as const;

export function isGuardProperty(item: unknown): item is GuardProperty {
    return reflection.isInstance(item, GuardProperty.$type);
}

export interface HydraulicProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'HydraulicProfile';
    name: string;
    statements: Array<HydraulicStatement>;
}

export const HydraulicProfile = {
    $type: 'HydraulicProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isHydraulicProfile(item: unknown): item is HydraulicProfile {
    return reflection.isInstance(item, HydraulicProfile.$type);
}

export type HydraulicStatement = FlowRateStatement | FluidStatement | NetStatement | PartStatement | PressureStatement;

export const HydraulicStatement = {
    $type: 'HydraulicStatement'
} as const;

export function isHydraulicStatement(item: unknown): item is HydraulicStatement {
    return reflection.isInstance(item, HydraulicStatement.$type);
}

export interface IconProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'IconProperty';
    icon: string;
    provider: string;
}

export const IconProperty = {
    $type: 'IconProperty',
    icon: 'icon',
    provider: 'provider'
} as const;

export function isIconProperty(item: unknown): item is IconProperty {
    return reflection.isInstance(item, IconProperty.$type);
}

export interface InputPinsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'InputPinsProperty';
    value: StringArray;
}

export const InputPinsProperty = {
    $type: 'InputPinsProperty',
    value: 'value'
} as const;

export function isInputPinsProperty(item: unknown): item is InputPinsProperty {
    return reflection.isInstance(item, InputPinsProperty.$type);
}

export interface InstMapProperty extends langium.AstNode {
    readonly $container: InstStatement;
    readonly $type: 'InstMapProperty';
    connections: Array<PortConnection>;
}

export const InstMapProperty = {
    $type: 'InstMapProperty',
    connections: 'connections'
} as const;

export function isInstMapProperty(item: unknown): item is InstMapProperty {
    return reflection.isInstance(item, InstMapProperty.$type);
}

export interface InstOfProperty extends langium.AstNode {
    readonly $container: InstStatement;
    readonly $type: 'InstOfProperty';
    module: string;
}

export const InstOfProperty = {
    $type: 'InstOfProperty',
    module: 'module'
} as const;

export function isInstOfProperty(item: unknown): item is InstOfProperty {
    return reflection.isInstance(item, InstOfProperty.$type);
}

export interface InstParamsProperty extends langium.AstNode {
    readonly $container: InstStatement;
    readonly $type: 'InstParamsProperty';
    params: Array<ParamOverride>;
}

export const InstParamsProperty = {
    $type: 'InstParamsProperty',
    params: 'params'
} as const;

export function isInstParamsProperty(item: unknown): item is InstParamsProperty {
    return reflection.isInstance(item, InstParamsProperty.$type);
}

export type InstProperty = InstMapProperty | InstOfProperty | InstParamsProperty;

export const InstProperty = {
    $type: 'InstProperty'
} as const;

export function isInstProperty(item: unknown): item is InstProperty {
    return reflection.isInstance(item, InstProperty.$type);
}

export type InstrumentLocation = 'control_room' | 'field' | 'local' | 'panel' | 'remote';

export function isInstrumentLocation(item: unknown): item is InstrumentLocation {
    return item === 'field' || item === 'panel' || item === 'local' || item === 'remote' || item === 'control_room';
}

export interface InstStatement extends langium.AstNode {
    readonly $container: DigitalProfile;
    readonly $type: 'InstStatement';
    properties: Array<InstProperty>;
    ref: string;
}

export const InstStatement = {
    $type: 'InstStatement',
    properties: 'properties',
    ref: 'ref'
} as const;

export function isInstStatement(item: unknown): item is InstStatement {
    return reflection.isInstance(item, InstStatement.$type);
}

export type InsulationType = 'acoustic' | 'fireproof' | 'none' | 'personnel_protection' | 'thermal';

export function isInsulationType(item: unknown): item is InsulationType {
    return item === 'none' || item === 'thermal' || item === 'acoustic' || item === 'fireproof' || item === 'personnel_protection';
}

export interface IntersectionsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'IntersectionsProperty';
    value: StringArray;
}

export const IntersectionsProperty = {
    $type: 'IntersectionsProperty',
    value: 'value'
} as const;

export function isIntersectionsProperty(item: unknown): item is IntersectionsProperty {
    return reflection.isInstance(item, IntersectionsProperty.$type);
}

export type LabelPositionValue = 'bottom' | 'left' | 'right' | 'top';

export function isLabelPositionValue(item: unknown): item is LabelPositionValue {
    return item === 'top' || item === 'bottom' || item === 'left' || item === 'right';
}

export interface LabelProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'LabelProperty';
    value: string;
}

export const LabelProperty = {
    $type: 'LabelProperty',
    value: 'value'
} as const;

export function isLabelProperty(item: unknown): item is LabelProperty {
    return reflection.isInstance(item, LabelProperty.$type);
}

export interface LabelsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'LabelsProperty';
    value: StringArray;
}

export const LabelsProperty = {
    $type: 'LabelsProperty',
    value: 'value'
} as const;

export function isLabelsProperty(item: unknown): item is LabelsProperty {
    return reflection.isInstance(item, LabelsProperty.$type);
}

export type LayoutAlgorithmValue = 'circular' | 'force' | 'layered' | 'mrtree' | 'radial' | 'stress';

export function isLayoutAlgorithmValue(item: unknown): item is LayoutAlgorithmValue {
    return item === 'layered' || item === 'force' || item === 'stress' || item === 'radial' || item === 'mrtree' || item === 'circular';
}

export type LayoutComplexityValue = 'high' | 'low' | 'medium';

export function isLayoutComplexityValue(item: unknown): item is LayoutComplexityValue {
    return item === 'low' || item === 'medium' || item === 'high';
}

export interface LegendPositionProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'LegendPositionProperty';
    value: string;
}

export const LegendPositionProperty = {
    $type: 'LegendPositionProperty',
    value: 'value'
} as const;

export function isLegendPositionProperty(item: unknown): item is LegendPositionProperty {
    return reflection.isInstance(item, LegendPositionProperty.$type);
}

export interface LineStyleProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'LineStyleProperty';
    value: string;
}

export const LineStyleProperty = {
    $type: 'LineStyleProperty',
    value: 'value'
} as const;

export function isLineStyleProperty(item: unknown): item is LineStyleProperty {
    return reflection.isInstance(item, LineStyleProperty.$type);
}

export interface LinkProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'LinkProperty';
    url: string;
}

export const LinkProperty = {
    $type: 'LinkProperty',
    url: 'url'
} as const;

export function isLinkProperty(item: unknown): item is LinkProperty {
    return reflection.isInstance(item, LinkProperty.$type);
}

export interface LoopBlock extends langium.AstNode {
    readonly $container: ConditionalBlock | ForEachBlock | LoopBlock;
    readonly $type: 'LoopBlock';
    collection: TemplateExpression;
    statements: Array<TemplateStatement>;
    variable: string;
}

export const LoopBlock = {
    $type: 'LoopBlock',
    collection: 'collection',
    statements: 'statements',
    variable: 'variable'
} as const;

export function isLoopBlock(item: unknown): item is LoopBlock {
    return reflection.isInstance(item, LoopBlock.$type);
}

export type MaterialType = 'Alloy20' | 'CS' | 'Hastelloy' | 'Monel' | 'PP' | 'PTFE' | 'PVC' | 'SS304' | 'SS316' | 'SS316L' | 'Titanium';

export function isMaterialType(item: unknown): item is MaterialType {
    return item === 'CS' || item === 'SS304' || item === 'SS316' || item === 'SS316L' || item === 'Alloy20' || item === 'Hastelloy' || item === 'Monel' || item === 'Titanium' || item === 'PVC' || item === 'PP' || item === 'PTFE';
}

export type MeasurementUnit = '%' | 'L/min' | 'bar' | 'degC' | 'degF' | 'kPa' | 'kg/h' | 'm' | 'mm' | 'mm/s' | 'm³/h' | 'psi' | 'rpm' | 't/h';

export function isMeasurementUnit(item: unknown): item is MeasurementUnit {
    return item === 'kg/h' || item === 't/h' || item === 'L/min' || item === 'm³/h' || item === 'degC' || item === 'degF' || item === 'bar' || item === 'psi' || item === 'kPa' || item === 'm' || item === 'mm' || item === '%' || item === 'rpm' || item === 'mm/s';
}

export interface MethodAbstractField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodAbstractField';
    value: BooleanValue;
}

export const MethodAbstractField = {
    $type: 'MethodAbstractField',
    value: 'value'
} as const;

export function isMethodAbstractField(item: unknown): item is MethodAbstractField {
    return reflection.isInstance(item, MethodAbstractField.$type);
}

export interface MethodConstraintsField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodConstraintsField';
    values: Array<string>;
}

export const MethodConstraintsField = {
    $type: 'MethodConstraintsField',
    values: 'values'
} as const;

export function isMethodConstraintsField(item: unknown): item is MethodConstraintsField {
    return reflection.isInstance(item, MethodConstraintsField.$type);
}

export interface MethodDecl extends langium.AstNode {
    readonly $container: MethodsProperty;
    readonly $type: 'MethodDecl';
    properties: Array<MethodField>;
}

export const MethodDecl = {
    $type: 'MethodDecl',
    properties: 'properties'
} as const;

export function isMethodDecl(item: unknown): item is MethodDecl {
    return reflection.isInstance(item, MethodDecl.$type);
}

export type MethodField = MethodAbstractField | MethodConstraintsField | MethodNameField | MethodParamsField | MethodReturnTypeField | MethodStaticField | MethodVisibilityField;

export const MethodField = {
    $type: 'MethodField'
} as const;

export function isMethodField(item: unknown): item is MethodField {
    return reflection.isInstance(item, MethodField.$type);
}

export interface MethodNameField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodNameField';
    value: string;
}

export const MethodNameField = {
    $type: 'MethodNameField',
    value: 'value'
} as const;

export function isMethodNameField(item: unknown): item is MethodNameField {
    return reflection.isInstance(item, MethodNameField.$type);
}

export interface MethodParamDecl extends langium.AstNode {
    readonly $container: MethodParamsField;
    readonly $type: 'MethodParamDecl';
    properties: Array<MethodParamField>;
}

export const MethodParamDecl = {
    $type: 'MethodParamDecl',
    properties: 'properties'
} as const;

export function isMethodParamDecl(item: unknown): item is MethodParamDecl {
    return reflection.isInstance(item, MethodParamDecl.$type);
}

export type MethodParamField = ParamNameField | ParamTypeField;

export const MethodParamField = {
    $type: 'MethodParamField'
} as const;

export function isMethodParamField(item: unknown): item is MethodParamField {
    return reflection.isInstance(item, MethodParamField.$type);
}

export interface MethodParamsField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodParamsField';
    params: Array<MethodParamDecl>;
}

export const MethodParamsField = {
    $type: 'MethodParamsField',
    params: 'params'
} as const;

export function isMethodParamsField(item: unknown): item is MethodParamsField {
    return reflection.isInstance(item, MethodParamsField.$type);
}

export interface MethodReturnTypeField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodReturnTypeField';
    value: string;
}

export const MethodReturnTypeField = {
    $type: 'MethodReturnTypeField',
    value: 'value'
} as const;

export function isMethodReturnTypeField(item: unknown): item is MethodReturnTypeField {
    return reflection.isInstance(item, MethodReturnTypeField.$type);
}

export interface MethodsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'MethodsProperty';
    methods: Array<MethodDecl>;
}

export const MethodsProperty = {
    $type: 'MethodsProperty',
    methods: 'methods'
} as const;

export function isMethodsProperty(item: unknown): item is MethodsProperty {
    return reflection.isInstance(item, MethodsProperty.$type);
}

export interface MethodStaticField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodStaticField';
    value: BooleanValue;
}

export const MethodStaticField = {
    $type: 'MethodStaticField',
    value: 'value'
} as const;

export function isMethodStaticField(item: unknown): item is MethodStaticField {
    return reflection.isInstance(item, MethodStaticField.$type);
}

export interface MethodVisibilityField extends langium.AstNode {
    readonly $container: MethodDecl;
    readonly $type: 'MethodVisibilityField';
    value: VisibilityValue;
}

export const MethodVisibilityField = {
    $type: 'MethodVisibilityField',
    value: 'value'
} as const;

export function isMethodVisibilityField(item: unknown): item is MethodVisibilityField {
    return reflection.isInstance(item, MethodVisibilityField.$type);
}

export interface MetricPositionProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'MetricPositionProperty';
    value: MetricPositionValue;
}

export const MetricPositionProperty = {
    $type: 'MetricPositionProperty',
    value: 'value'
} as const;

export function isMetricPositionProperty(item: unknown): item is MetricPositionProperty {
    return reflection.isInstance(item, MetricPositionProperty.$type);
}

export type MetricPositionValue = 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right';

export function isMetricPositionValue(item: unknown): item is MetricPositionValue {
    return item === 'top-right' || item === 'top-left' || item === 'bottom-right' || item === 'bottom-left';
}

export interface MetricTypeProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'MetricTypeProperty';
    value: MetricTypeValue;
}

export const MetricTypeProperty = {
    $type: 'MetricTypeProperty',
    value: 'value'
} as const;

export function isMetricTypeProperty(item: unknown): item is MetricTypeProperty {
    return reflection.isInstance(item, MetricTypeProperty.$type);
}

export type MetricTypeValue = 'betweenness' | 'closeness' | 'clustering' | 'degree';

export function isMetricTypeValue(item: unknown): item is MetricTypeValue {
    return item === 'degree' || item === 'betweenness' || item === 'closeness' || item === 'clustering';
}

export interface ModuleParamsProperty extends langium.AstNode {
    readonly $container: ModuleStatement;
    readonly $type: 'ModuleParamsProperty';
    params: Array<ParamDecl>;
}

export const ModuleParamsProperty = {
    $type: 'ModuleParamsProperty',
    params: 'params'
} as const;

export function isModuleParamsProperty(item: unknown): item is ModuleParamsProperty {
    return reflection.isInstance(item, ModuleParamsProperty.$type);
}

export interface ModulePortsProperty extends langium.AstNode {
    readonly $container: ModuleStatement;
    readonly $type: 'ModulePortsProperty';
    ports: Array<PortDecl>;
}

export const ModulePortsProperty = {
    $type: 'ModulePortsProperty',
    ports: 'ports'
} as const;

export function isModulePortsProperty(item: unknown): item is ModulePortsProperty {
    return reflection.isInstance(item, ModulePortsProperty.$type);
}

export type ModuleProperty = ModuleParamsProperty | ModulePortsProperty;

export const ModuleProperty = {
    $type: 'ModuleProperty'
} as const;

export function isModuleProperty(item: unknown): item is ModuleProperty {
    return reflection.isInstance(item, ModuleProperty.$type);
}

export interface ModuleStatement extends langium.AstNode {
    readonly $container: DigitalProfile;
    readonly $type: 'ModuleStatement';
    name: string;
    properties: Array<ModuleProperty>;
}

export const ModuleStatement = {
    $type: 'ModuleStatement',
    name: 'name',
    properties: 'properties'
} as const;

export function isModuleStatement(item: unknown): item is ModuleStatement {
    return reflection.isInstance(item, ModuleStatement.$type);
}

export interface MultiplicitySourceProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'MultiplicitySourceProperty';
    value: string;
}

export const MultiplicitySourceProperty = {
    $type: 'MultiplicitySourceProperty',
    value: 'value'
} as const;

export function isMultiplicitySourceProperty(item: unknown): item is MultiplicitySourceProperty {
    return reflection.isInstance(item, MultiplicitySourceProperty.$type);
}

export interface MultiplicityTargetProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'MultiplicityTargetProperty';
    value: string;
}

export const MultiplicityTargetProperty = {
    $type: 'MultiplicityTargetProperty',
    value: 'value'
} as const;

export function isMultiplicityTargetProperty(item: unknown): item is MultiplicityTargetProperty {
    return reflection.isInstance(item, MultiplicityTargetProperty.$type);
}

export type NavigabilityDirection = 'bidirectional' | 'none' | 'source' | 'target';

export function isNavigabilityDirection(item: unknown): item is NavigabilityDirection {
    return item === 'source' || item === 'target' || item === 'bidirectional' || item === 'none';
}

export interface NavigabilityProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'NavigabilityProperty';
    value: NavigabilityDirection;
}

export const NavigabilityProperty = {
    $type: 'NavigabilityProperty',
    value: 'value'
} as const;

export function isNavigabilityProperty(item: unknown): item is NavigabilityProperty {
    return reflection.isInstance(item, NavigabilityProperty.$type);
}

export interface NetDecl extends langium.AstNode {
    readonly $container: DigitalNetStatement;
    readonly $type: 'NetDecl';
    name: string;
    width?: BusWidth;
}

export const NetDecl = {
    $type: 'NetDecl',
    name: 'name',
    width: 'width'
} as const;

export function isNetDecl(item: unknown): item is NetDecl {
    return reflection.isInstance(item, NetDecl.$type);
}

export interface NetStatement extends langium.AstNode {
    readonly $container: ElectricalProfile | HydraulicProfile | PneumaticProfile;
    readonly $type: 'NetStatement';
    names: Array<string>;
}

export const NetStatement = {
    $type: 'NetStatement',
    names: 'names'
} as const;

export function isNetStatement(item: unknown): item is NetStatement {
    return reflection.isInstance(item, NetStatement.$type);
}

export type NodeProperty = AffectedProperty | AttributesProperty | BorderRadiusProperty | CarrierProperty | ColorsProperty | DataProperty | DeceasedProperty | DoActivityProperty | EntryProperty | ExitProperty | ExtensionPointsProperty | FillColorProperty | FlipAxesProperty | FontFamilyProperty | FontSizeProperty | FontWeightProperty | GatewayTypeProperty | GenericTypesProperty | IconProperty | InputPinsProperty | IntersectionsProperty | LabelProperty | LabelsProperty | LegendPositionProperty | LinkProperty | MethodsProperty | MetricPositionProperty | MetricTypeProperty | OpacityProperty | OutputPinsProperty | PositionProperty | ShowLegendProperty | ShowMetricsProperty | ShowValuesProperty | StackedProperty | StateInvariantProperty | StereotypeProperty | StrokeColorProperty | StrokeWidthProperty | StyleRefProperty | TextAlignProperty | TextColorProperty | TitleProperty | TooltipProperty | XLabelProperty | YLabelProperty;

export const NodeProperty = {
    $type: 'NodeProperty'
} as const;

export function isNodeProperty(item: unknown): item is NodeProperty {
    return reflection.isInstance(item, NodeProperty.$type);
}

export interface NodeRef extends langium.AstNode {
    readonly $container: EdgeChain | EdgeDeclaration;
    readonly $type: 'NodeRef';
    member?: FlexibleID;
    node: FlexibleID;
}

export const NodeRef = {
    $type: 'NodeRef',
    member: 'member',
    node: 'node'
} as const;

export function isNodeRef(item: unknown): item is NodeRef {
    return reflection.isInstance(item, NodeRef.$type);
}

export interface OpacityProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'OpacityProperty';
    value: string;
}

export const OpacityProperty = {
    $type: 'OpacityProperty',
    value: 'value'
} as const;

export function isOpacityProperty(item: unknown): item is OpacityProperty {
    return reflection.isInstance(item, OpacityProperty.$type);
}

export type OrientationValue = 'horizontal' | 'vertical';

export function isOrientationValue(item: unknown): item is OrientationValue {
    return item === 'horizontal' || item === 'vertical';
}

export interface OutputPinsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'OutputPinsProperty';
    value: StringArray;
}

export const OutputPinsProperty = {
    $type: 'OutputPinsProperty',
    value: 'value'
} as const;

export function isOutputPinsProperty(item: unknown): item is OutputPinsProperty {
    return reflection.isInstance(item, OutputPinsProperty.$type);
}

export interface ParamDecl extends langium.AstNode {
    readonly $container: ModuleParamsProperty;
    readonly $type: 'ParamDecl';
    name: string;
    value: string;
}

export const ParamDecl = {
    $type: 'ParamDecl',
    name: 'name',
    value: 'value'
} as const;

export function isParamDecl(item: unknown): item is ParamDecl {
    return reflection.isInstance(item, ParamDecl.$type);
}

export interface ParamNameField extends langium.AstNode {
    readonly $container: MethodParamDecl;
    readonly $type: 'ParamNameField';
    value: string;
}

export const ParamNameField = {
    $type: 'ParamNameField',
    value: 'value'
} as const;

export function isParamNameField(item: unknown): item is ParamNameField {
    return reflection.isInstance(item, ParamNameField.$type);
}

export interface ParamOverride extends langium.AstNode {
    readonly $container: InstParamsProperty;
    readonly $type: 'ParamOverride';
    param: string;
    value: string;
}

export const ParamOverride = {
    $type: 'ParamOverride',
    param: 'param',
    value: 'value'
} as const;

export function isParamOverride(item: unknown): item is ParamOverride {
    return reflection.isInstance(item, ParamOverride.$type);
}

export interface ParamTypeField extends langium.AstNode {
    readonly $container: MethodParamDecl;
    readonly $type: 'ParamTypeField';
    value: string;
}

export const ParamTypeField = {
    $type: 'ParamTypeField',
    value: 'value'
} as const;

export function isParamTypeField(item: unknown): item is ParamTypeField {
    return reflection.isInstance(item, ParamTypeField.$type);
}

export interface PartGenericProperty extends langium.AstNode {
    readonly $container: PartStatement;
    readonly $type: 'PartGenericProperty';
    key: 'ratio' | string;
    value: string;
}

export const PartGenericProperty = {
    $type: 'PartGenericProperty',
    key: 'key',
    value: 'value'
} as const;

export function isPartGenericProperty(item: unknown): item is PartGenericProperty {
    return reflection.isInstance(item, PartGenericProperty.$type);
}

export interface PartPinsProperty extends langium.AstNode {
    readonly $container: PartStatement;
    readonly $type: 'PartPinsProperty';
    pins: Array<string>;
}

export const PartPinsProperty = {
    $type: 'PartPinsProperty',
    pins: 'pins'
} as const;

export function isPartPinsProperty(item: unknown): item is PartPinsProperty {
    return reflection.isInstance(item, PartPinsProperty.$type);
}

export type PartProperty = PartGenericProperty | PartPinsProperty | PartSourceProperty | PartTypeProperty | PartValueProperty;

export const PartProperty = {
    $type: 'PartProperty'
} as const;

export function isPartProperty(item: unknown): item is PartProperty {
    return reflection.isInstance(item, PartProperty.$type);
}

export interface PartSourceProperty extends langium.AstNode {
    readonly $container: PartStatement;
    readonly $type: 'PartSourceProperty';
    source: string;
}

export const PartSourceProperty = {
    $type: 'PartSourceProperty',
    source: 'source'
} as const;

export function isPartSourceProperty(item: unknown): item is PartSourceProperty {
    return reflection.isInstance(item, PartSourceProperty.$type);
}

export interface PartStatement extends langium.AstNode {
    readonly $container: ElectricalProfile | HydraulicProfile | PneumaticProfile;
    readonly $type: 'PartStatement';
    properties: Array<PartProperty>;
    ref: string;
}

export const PartStatement = {
    $type: 'PartStatement',
    properties: 'properties',
    ref: 'ref'
} as const;

export function isPartStatement(item: unknown): item is PartStatement {
    return reflection.isInstance(item, PartStatement.$type);
}

export interface PartTypeProperty extends langium.AstNode {
    readonly $container: PartStatement;
    readonly $type: 'PartTypeProperty';
    type: 'L' | string;
}

export const PartTypeProperty = {
    $type: 'PartTypeProperty',
    type: 'type'
} as const;

export function isPartTypeProperty(item: unknown): item is PartTypeProperty {
    return reflection.isInstance(item, PartTypeProperty.$type);
}

export interface PartValueProperty extends langium.AstNode {
    readonly $container: PartStatement;
    readonly $type: 'PartValueProperty';
    value: string;
}

export const PartValueProperty = {
    $type: 'PartValueProperty',
    value: 'value'
} as const;

export function isPartValueProperty(item: unknown): item is PartValueProperty {
    return reflection.isInstance(item, PartValueProperty.$type);
}

export interface PIDAccuracyProperty extends langium.AstNode {
    readonly $container: PIDInstrumentStatement;
    readonly $type: 'PIDAccuracyProperty';
    unit: AccuracyUnit;
    value: string;
}

export const PIDAccuracyProperty = {
    $type: 'PIDAccuracyProperty',
    unit: 'unit',
    value: 'value'
} as const;

export function isPIDAccuracyProperty(item: unknown): item is PIDAccuracyProperty {
    return reflection.isInstance(item, PIDAccuracyProperty.$type);
}

export interface PIDControlledVariableProperty extends langium.AstNode {
    readonly $container: PIDLoopStatement;
    readonly $type: 'PIDControlledVariableProperty';
    variable: ControlVariable;
}

export const PIDControlledVariableProperty = {
    $type: 'PIDControlledVariableProperty',
    variable: 'variable'
} as const;

export function isPIDControlledVariableProperty(item: unknown): item is PIDControlledVariableProperty {
    return reflection.isInstance(item, PIDControlledVariableProperty.$type);
}

export interface PIDControllerProperty extends langium.AstNode {
    readonly $container: PIDLoopStatement;
    readonly $type: 'PIDControllerProperty';
    tag: string;
}

export const PIDControllerProperty = {
    $type: 'PIDControllerProperty',
    tag: 'tag'
} as const;

export function isPIDControllerProperty(item: unknown): item is PIDControllerProperty {
    return reflection.isInstance(item, PIDControllerProperty.$type);
}

export interface PIDControlModeProperty extends langium.AstNode {
    readonly $container: PIDLoopStatement;
    readonly $type: 'PIDControlModeProperty';
    mode: ControlMode;
}

export const PIDControlModeProperty = {
    $type: 'PIDControlModeProperty',
    mode: 'mode'
} as const;

export function isPIDControlModeProperty(item: unknown): item is PIDControlModeProperty {
    return reflection.isInstance(item, PIDControlModeProperty.$type);
}

export interface PIDDimensionProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDDimensionProperty';
    unit: DimensionUnit;
    value: string;
}

export const PIDDimensionProperty = {
    $type: 'PIDDimensionProperty',
    unit: 'unit',
    value: 'value'
} as const;

export function isPIDDimensionProperty(item: unknown): item is PIDDimensionProperty {
    return reflection.isInstance(item, PIDDimensionProperty.$type);
}

export type PIDEquipmentProperty = GenericPIDProperty | PIDDimensionProperty | PIDEquipmentTypeProperty | PIDFlowRateProperty | PIDMaterialProperty | PIDRatingProperty | PIDVolumeProperty;

export const PIDEquipmentProperty = {
    $type: 'PIDEquipmentProperty'
} as const;

export function isPIDEquipmentProperty(item: unknown): item is PIDEquipmentProperty {
    return reflection.isInstance(item, PIDEquipmentProperty.$type);
}

export interface PIDEquipmentStatement extends langium.AstNode {
    readonly $container: PIDProfile;
    readonly $type: 'PIDEquipmentStatement';
    properties: Array<PIDEquipmentProperty>;
    tag: string;
}

export const PIDEquipmentStatement = {
    $type: 'PIDEquipmentStatement',
    properties: 'properties',
    tag: 'tag'
} as const;

export function isPIDEquipmentStatement(item: unknown): item is PIDEquipmentStatement {
    return reflection.isInstance(item, PIDEquipmentStatement.$type);
}

export type PIDEquipmentType = 'agitator' | 'airCooler' | 'compressorCentrifugal' | 'compressorReciprocating' | 'condenser' | 'cooler' | 'coolingTower' | 'cyclone' | 'distillationColumn' | 'fan' | 'filter' | 'firedHeater' | 'flashDrum' | 'heatExchangerPlate' | 'heatExchangerShellTube' | 'jacket' | 'knockoutDrum' | 'pumpCentrifugal' | 'pumpPositiveDisplacement' | 'reactor' | 'reboiler' | 'refluxDrum' | 'ruptureDisk' | 'separator' | 'separatorHorizontal' | 'storageTank' | 'turbineSteam' | 'valveAngle' | 'valveBall' | 'valveButterfly' | 'valveCheck' | 'valveControl' | 'valveDiaphragm' | 'valveGate' | 'valveGlobe' | 'valveNeedle' | 'valvePinch' | 'valvePlug' | 'valveSafetyRelief' | 'valveShutoff' | 'valveThreeWay' | 'vesselHorizontal' | 'vesselVertical';

export function isPIDEquipmentType(item: unknown): item is PIDEquipmentType {
    return item === 'vesselVertical' || item === 'vesselHorizontal' || item === 'storageTank' || item === 'reactor' || item === 'knockoutDrum' || item === 'distillationColumn' || item === 'filter' || item === 'separator' || item === 'separatorHorizontal' || item === 'flashDrum' || item === 'refluxDrum' || item === 'cyclone' || item === 'pumpCentrifugal' || item === 'pumpPositiveDisplacement' || item === 'compressorCentrifugal' || item === 'compressorReciprocating' || item === 'turbineSteam' || item === 'fan' || item === 'agitator' || item === 'valveGate' || item === 'valveGlobe' || item === 'valveBall' || item === 'valveCheck' || item === 'valveControl' || item === 'valveSafetyRelief' || item === 'valveButterfly' || item === 'valveThreeWay' || item === 'valveNeedle' || item === 'valvePlug' || item === 'valveDiaphragm' || item === 'valveAngle' || item === 'valvePinch' || item === 'valveShutoff' || item === 'heatExchangerShellTube' || item === 'cooler' || item === 'airCooler' || item === 'heatExchangerPlate' || item === 'firedHeater' || item === 'coolingTower' || item === 'condenser' || item === 'reboiler' || item === 'jacket' || item === 'ruptureDisk';
}

export interface PIDEquipmentTypeProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDEquipmentTypeProperty';
    type: PIDEquipmentType;
}

export const PIDEquipmentTypeProperty = {
    $type: 'PIDEquipmentTypeProperty',
    type: 'type'
} as const;

export function isPIDEquipmentTypeProperty(item: unknown): item is PIDEquipmentTypeProperty {
    return reflection.isInstance(item, PIDEquipmentTypeProperty.$type);
}

export interface PIDFlowRateProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDFlowRateProperty';
    unit: FlowRateUnit;
    value: string;
}

export const PIDFlowRateProperty = {
    $type: 'PIDFlowRateProperty',
    unit: 'unit',
    value: 'value'
} as const;

export function isPIDFlowRateProperty(item: unknown): item is PIDFlowRateProperty {
    return reflection.isInstance(item, PIDFlowRateProperty.$type);
}

export type PIDInstrumentProperty = GenericPIDProperty | PIDAccuracyProperty | PIDInstrumentTypeProperty | PIDLocationProperty | PIDLoopRefProperty | PIDRangeProperty;

export const PIDInstrumentProperty = {
    $type: 'PIDInstrumentProperty'
} as const;

export function isPIDInstrumentProperty(item: unknown): item is PIDInstrumentProperty {
    return reflection.isInstance(item, PIDInstrumentProperty.$type);
}

export interface PIDInstrumentStatement extends langium.AstNode {
    readonly $container: PIDProfile;
    readonly $type: 'PIDInstrumentStatement';
    properties: Array<PIDInstrumentProperty>;
    tag: string;
}

export const PIDInstrumentStatement = {
    $type: 'PIDInstrumentStatement',
    properties: 'properties',
    tag: 'tag'
} as const;

export function isPIDInstrumentStatement(item: unknown): item is PIDInstrumentStatement {
    return reflection.isInstance(item, PIDInstrumentStatement.$type);
}

export type PIDInstrumentType = 'analyzerTransmitter' | 'conductivityTransmitter' | 'flowAlarmHigh' | 'flowAlarmLow' | 'flowController' | 'flowIndicator' | 'flowIndicatorController' | 'flowRecorder' | 'flowSwitch' | 'flowTransmitter' | 'levelAlarmHigh' | 'levelAlarmHighHigh' | 'levelAlarmLow' | 'levelAlarmLowLow' | 'levelController' | 'levelIndicator' | 'levelIndicatorController' | 'levelSwitch' | 'levelTransmitter' | 'phTransmitter' | 'pressureAlarmHigh' | 'pressureAlarmHighHigh' | 'pressureAlarmLow' | 'pressureAlarmLowLow' | 'pressureController' | 'pressureIndicator' | 'pressureIndicatorController' | 'pressureRecorder' | 'pressureSwitch' | 'pressureTransmitter' | 'speedController' | 'temperatureAlarmHigh' | 'temperatureAlarmHighHigh' | 'temperatureAlarmLow' | 'temperatureAlarmLowLow' | 'temperatureController' | 'temperatureIndicator' | 'temperatureIndicatorController' | 'temperatureRecorder' | 'temperatureSwitch' | 'temperatureTransmitter' | 'vibrationTransmitter';

export function isPIDInstrumentType(item: unknown): item is PIDInstrumentType {
    return item === 'flowTransmitter' || item === 'temperatureTransmitter' || item === 'pressureTransmitter' || item === 'levelTransmitter' || item === 'analyzerTransmitter' || item === 'phTransmitter' || item === 'conductivityTransmitter' || item === 'vibrationTransmitter' || item === 'flowIndicator' || item === 'temperatureIndicator' || item === 'pressureIndicator' || item === 'levelIndicator' || item === 'flowController' || item === 'temperatureController' || item === 'pressureController' || item === 'levelController' || item === 'speedController' || item === 'flowIndicatorController' || item === 'temperatureIndicatorController' || item === 'levelIndicatorController' || item === 'pressureIndicatorController' || item === 'flowSwitch' || item === 'levelSwitch' || item === 'pressureSwitch' || item === 'temperatureSwitch' || item === 'temperatureAlarmHigh' || item === 'temperatureAlarmLow' || item === 'temperatureAlarmHighHigh' || item === 'temperatureAlarmLowLow' || item === 'pressureAlarmHigh' || item === 'pressureAlarmLow' || item === 'pressureAlarmHighHigh' || item === 'pressureAlarmLowLow' || item === 'levelAlarmHigh' || item === 'levelAlarmLow' || item === 'levelAlarmHighHigh' || item === 'levelAlarmLowLow' || item === 'flowAlarmHigh' || item === 'flowAlarmLow' || item === 'flowRecorder' || item === 'pressureRecorder' || item === 'temperatureRecorder';
}

export interface PIDInstrumentTypeProperty extends langium.AstNode {
    readonly $container: PIDInstrumentStatement;
    readonly $type: 'PIDInstrumentTypeProperty';
    type: PIDInstrumentType;
}

export const PIDInstrumentTypeProperty = {
    $type: 'PIDInstrumentTypeProperty',
    type: 'type'
} as const;

export function isPIDInstrumentTypeProperty(item: unknown): item is PIDInstrumentTypeProperty {
    return reflection.isInstance(item, PIDInstrumentTypeProperty.$type);
}

export interface PIDLineFromProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineFromProperty';
    from: ConnectionPoint;
}

export const PIDLineFromProperty = {
    $type: 'PIDLineFromProperty',
    from: 'from'
} as const;

export function isPIDLineFromProperty(item: unknown): item is PIDLineFromProperty {
    return reflection.isInstance(item, PIDLineFromProperty.$type);
}

export interface PIDLineInsulationProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineInsulationProperty';
    type: InsulationType;
}

export const PIDLineInsulationProperty = {
    $type: 'PIDLineInsulationProperty',
    type: 'type'
} as const;

export function isPIDLineInsulationProperty(item: unknown): item is PIDLineInsulationProperty {
    return reflection.isInstance(item, PIDLineInsulationProperty.$type);
}

export interface PIDLineMaterialProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineMaterialProperty';
    material: MaterialType;
}

export const PIDLineMaterialProperty = {
    $type: 'PIDLineMaterialProperty',
    material: 'material'
} as const;

export function isPIDLineMaterialProperty(item: unknown): item is PIDLineMaterialProperty {
    return reflection.isInstance(item, PIDLineMaterialProperty.$type);
}

export type PIDLineProperty = GenericPIDProperty | PIDLineFromProperty | PIDLineInsulationProperty | PIDLineMaterialProperty | PIDLineScheduleProperty | PIDLineSizeProperty | PIDLineToProperty;

export const PIDLineProperty = {
    $type: 'PIDLineProperty'
} as const;

export function isPIDLineProperty(item: unknown): item is PIDLineProperty {
    return reflection.isInstance(item, PIDLineProperty.$type);
}

export interface PIDLineScheduleProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineScheduleProperty';
    schedule: PipeSchedule;
}

export const PIDLineScheduleProperty = {
    $type: 'PIDLineScheduleProperty',
    schedule: 'schedule'
} as const;

export function isPIDLineScheduleProperty(item: unknown): item is PIDLineScheduleProperty {
    return reflection.isInstance(item, PIDLineScheduleProperty.$type);
}

export interface PIDLineSizeProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineSizeProperty';
    size: string;
    unit?: SizeUnit;
}

export const PIDLineSizeProperty = {
    $type: 'PIDLineSizeProperty',
    size: 'size',
    unit: 'unit'
} as const;

export function isPIDLineSizeProperty(item: unknown): item is PIDLineSizeProperty {
    return reflection.isInstance(item, PIDLineSizeProperty.$type);
}

export interface PIDLineStatement extends langium.AstNode {
    readonly $container: PIDProfile;
    readonly $type: 'PIDLineStatement';
    lineType: PIDLineType;
    properties: Array<PIDLineProperty>;
    style?: PIDLineStyle;
}

export const PIDLineStatement = {
    $type: 'PIDLineStatement',
    lineType: 'lineType',
    properties: 'properties',
    style: 'style'
} as const;

export function isPIDLineStatement(item: unknown): item is PIDLineStatement {
    return reflection.isInstance(item, PIDLineStatement.$type);
}

export type PIDLineStyle = 'dashed' | 'dotted' | 'double' | 'future' | 'solid';

export function isPIDLineStyle(item: unknown): item is PIDLineStyle {
    return item === 'solid' || item === 'dashed' || item === 'dotted' || item === 'double' || item === 'future';
}

export interface PIDLineToProperty extends langium.AstNode {
    readonly $container: PIDLineStatement;
    readonly $type: 'PIDLineToProperty';
    to: ConnectionPoint;
}

export const PIDLineToProperty = {
    $type: 'PIDLineToProperty',
    to: 'to'
} as const;

export function isPIDLineToProperty(item: unknown): item is PIDLineToProperty {
    return reflection.isInstance(item, PIDLineToProperty.$type);
}

export type PIDLineType = 'data' | 'electrical' | 'hydraulic' | 'pneumatic' | 'process' | 'signal' | 'utility';

export function isPIDLineType(item: unknown): item is PIDLineType {
    return item === 'process' || item === 'utility' || item === 'signal' || item === 'electrical' || item === 'pneumatic' || item === 'hydraulic' || item === 'data';
}

export interface PIDLocationProperty extends langium.AstNode {
    readonly $container: PIDInstrumentStatement;
    readonly $type: 'PIDLocationProperty';
    location: InstrumentLocation;
}

export const PIDLocationProperty = {
    $type: 'PIDLocationProperty',
    location: 'location'
} as const;

export function isPIDLocationProperty(item: unknown): item is PIDLocationProperty {
    return reflection.isInstance(item, PIDLocationProperty.$type);
}

export type PIDLoopProperty = GenericPIDProperty | PIDControlModeProperty | PIDControlledVariableProperty | PIDControllerProperty | PIDSetpointProperty;

export const PIDLoopProperty = {
    $type: 'PIDLoopProperty'
} as const;

export function isPIDLoopProperty(item: unknown): item is PIDLoopProperty {
    return reflection.isInstance(item, PIDLoopProperty.$type);
}

export interface PIDLoopRefProperty extends langium.AstNode {
    readonly $container: PIDInstrumentStatement;
    readonly $type: 'PIDLoopRefProperty';
    loopNum: string;
}

export const PIDLoopRefProperty = {
    $type: 'PIDLoopRefProperty',
    loopNum: 'loopNum'
} as const;

export function isPIDLoopRefProperty(item: unknown): item is PIDLoopRefProperty {
    return reflection.isInstance(item, PIDLoopRefProperty.$type);
}

export interface PIDLoopStatement extends langium.AstNode {
    readonly $container: PIDProfile;
    readonly $type: 'PIDLoopStatement';
    loopNum: string;
    properties: Array<PIDLoopProperty>;
}

export const PIDLoopStatement = {
    $type: 'PIDLoopStatement',
    loopNum: 'loopNum',
    properties: 'properties'
} as const;

export function isPIDLoopStatement(item: unknown): item is PIDLoopStatement {
    return reflection.isInstance(item, PIDLoopStatement.$type);
}

export interface PIDMaterialProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDMaterialProperty';
    material: MaterialType;
}

export const PIDMaterialProperty = {
    $type: 'PIDMaterialProperty',
    material: 'material'
} as const;

export function isPIDMaterialProperty(item: unknown): item is PIDMaterialProperty {
    return reflection.isInstance(item, PIDMaterialProperty.$type);
}

export interface PIDProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'PIDProfile';
    name: string;
    statements: Array<PIDStatement>;
}

export const PIDProfile = {
    $type: 'PIDProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isPIDProfile(item: unknown): item is PIDProfile {
    return reflection.isInstance(item, PIDProfile.$type);
}

export interface PIDRangeProperty extends langium.AstNode {
    readonly $container: PIDInstrumentStatement;
    readonly $type: 'PIDRangeProperty';
    max: string;
    min: string;
    unit: MeasurementUnit;
}

export const PIDRangeProperty = {
    $type: 'PIDRangeProperty',
    max: 'max',
    min: 'min',
    unit: 'unit'
} as const;

export function isPIDRangeProperty(item: unknown): item is PIDRangeProperty {
    return reflection.isInstance(item, PIDRangeProperty.$type);
}

export interface PIDRatingProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDRatingProperty';
    rating: PressureRating;
}

export const PIDRatingProperty = {
    $type: 'PIDRatingProperty',
    rating: 'rating'
} as const;

export function isPIDRatingProperty(item: unknown): item is PIDRatingProperty {
    return reflection.isInstance(item, PIDRatingProperty.$type);
}

export interface PIDSetpointProperty extends langium.AstNode {
    readonly $container: PIDLoopStatement;
    readonly $type: 'PIDSetpointProperty';
    unit?: MeasurementUnit;
    value: string;
}

export const PIDSetpointProperty = {
    $type: 'PIDSetpointProperty',
    unit: 'unit',
    value: 'value'
} as const;

export function isPIDSetpointProperty(item: unknown): item is PIDSetpointProperty {
    return reflection.isInstance(item, PIDSetpointProperty.$type);
}

export type PIDStatement = FlowRateStatement | FluidStatement | PIDEquipmentStatement | PIDInstrumentStatement | PIDLineStatement | PIDLoopStatement | PressureStatement;

export const PIDStatement = {
    $type: 'PIDStatement'
} as const;

export function isPIDStatement(item: unknown): item is PIDStatement {
    return reflection.isInstance(item, PIDStatement.$type);
}

export interface PIDVolumeProperty extends langium.AstNode {
    readonly $container: PIDEquipmentStatement;
    readonly $type: 'PIDVolumeProperty';
    unit: VolumeUnit;
    value: string;
}

export const PIDVolumeProperty = {
    $type: 'PIDVolumeProperty',
    unit: 'unit',
    value: 'value'
} as const;

export function isPIDVolumeProperty(item: unknown): item is PIDVolumeProperty {
    return reflection.isInstance(item, PIDVolumeProperty.$type);
}

export type PipeSchedule = 'SCH10' | 'SCH100' | 'SCH120' | 'SCH140' | 'SCH160' | 'SCH20' | 'SCH30' | 'SCH40' | 'SCH5' | 'SCH60' | 'SCH80' | 'STD' | 'XS' | 'XXS';

export function isPipeSchedule(item: unknown): item is PipeSchedule {
    return item === 'SCH5' || item === 'SCH10' || item === 'SCH20' || item === 'SCH30' || item === 'STD' || item === 'SCH40' || item === 'SCH60' || item === 'XS' || item === 'SCH80' || item === 'SCH100' || item === 'SCH120' || item === 'SCH140' || item === 'SCH160' || item === 'XXS';
}

export interface PneumaticProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'PneumaticProfile';
    name: string;
    statements: Array<PneumaticStatement>;
}

export const PneumaticProfile = {
    $type: 'PneumaticProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isPneumaticProfile(item: unknown): item is PneumaticProfile {
    return reflection.isInstance(item, PneumaticProfile.$type);
}

export type PneumaticStatement = FlowRateStatement | NetStatement | PartStatement | PressureStatement;

export const PneumaticStatement = {
    $type: 'PneumaticStatement'
} as const;

export function isPneumaticStatement(item: unknown): item is PneumaticStatement {
    return reflection.isInstance(item, PneumaticStatement.$type);
}

export interface PortConnection extends langium.AstNode {
    readonly $container: InstMapProperty;
    readonly $type: 'PortConnection';
    net: string;
    port: string;
    range?: BusWidth;
}

export const PortConnection = {
    $type: 'PortConnection',
    net: 'net',
    port: 'port',
    range: 'range'
} as const;

export function isPortConnection(item: unknown): item is PortConnection {
    return reflection.isInstance(item, PortConnection.$type);
}

export interface PortDecl extends langium.AstNode {
    readonly $container: ModulePortsProperty;
    readonly $type: 'PortDecl';
    name: string;
    width?: BusWidth;
}

export const PortDecl = {
    $type: 'PortDecl',
    name: 'name',
    width: 'width'
} as const;

export function isPortDecl(item: unknown): item is PortDecl {
    return reflection.isInstance(item, PortDecl.$type);
}

export interface PositionProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'PositionProperty';
    x: string;
    y: string;
}

export const PositionProperty = {
    $type: 'PositionProperty',
    x: 'x',
    y: 'y'
} as const;

export function isPositionProperty(item: unknown): item is PositionProperty {
    return reflection.isInstance(item, PositionProperty.$type);
}

export interface PresetBlock extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'PresetBlock';
    id: string;
    label?: string;
    properties: Array<ContainerStyleProperty>;
}

export const PresetBlock = {
    $type: 'PresetBlock',
    id: 'id',
    label: 'label',
    properties: 'properties'
} as const;

export function isPresetBlock(item: unknown): item is PresetBlock {
    return reflection.isInstance(item, PresetBlock.$type);
}

export type PressureRating = '150#' | '1500#' | '2500#' | '300#' | '600#' | '900#' | 'PN10' | 'PN16' | 'PN25' | 'PN40';

export function isPressureRating(item: unknown): item is PressureRating {
    return item === '150#' || item === '300#' || item === '600#' || item === '900#' || item === '1500#' || item === '2500#' || item === 'PN10' || item === 'PN16' || item === 'PN25' || item === 'PN40';
}

export interface PressureStatement extends langium.AstNode {
    readonly $container: HydraulicProfile | PIDProfile | PneumaticProfile;
    readonly $type: 'PressureStatement';
    type?: PressureType;
    unit: PressureUnit;
    value: string;
}

export const PressureStatement = {
    $type: 'PressureStatement',
    type: 'type',
    unit: 'unit',
    value: 'value'
} as const;

export function isPressureStatement(item: unknown): item is PressureStatement {
    return reflection.isInstance(item, PressureStatement.$type);
}

export type PressureType = 'max' | 'min' | 'operating' | 'rated';

export function isPressureType(item: unknown): item is PressureType {
    return item === 'operating' || item === 'max' || item === 'min' || item === 'rated';
}

export type PressureUnit = 'MPa' | 'bar' | 'kPa' | 'psi';

export function isPressureUnit(item: unknown): item is PressureUnit {
    return item === 'bar' || item === 'psi' || item === 'kPa' || item === 'MPa';
}

export type Profile = DiagramProfile | DigitalProfile | ElectricalProfile | GlyphSetProfile | HydraulicProfile | PIDProfile | PneumaticProfile | SequenceProfile | TimelineProfile | WardleyProfile;

export const Profile = {
    $type: 'Profile'
} as const;

export function isProfile(item: unknown): item is Profile {
    return reflection.isInstance(item, Profile.$type);
}

export type ResizeHandleValue = 'e' | 'n' | 'ne' | 'nw' | 's' | 'se' | 'sw' | 'w';

export function isResizeHandleValue(item: unknown): item is ResizeHandleValue {
    return item === 'n' || item === 's' || item === 'e' || item === 'w' || item === 'ne' || item === 'nw' || item === 'se' || item === 'sw';
}

export interface RoleSourceProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'RoleSourceProperty';
    value: string;
}

export const RoleSourceProperty = {
    $type: 'RoleSourceProperty',
    value: 'value'
} as const;

export function isRoleSourceProperty(item: unknown): item is RoleSourceProperty {
    return reflection.isInstance(item, RoleSourceProperty.$type);
}

export interface RoleTargetProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'RoleTargetProperty';
    value: string;
}

export const RoleTargetProperty = {
    $type: 'RoleTargetProperty',
    value: 'value'
} as const;

export function isRoleTargetProperty(item: unknown): item is RoleTargetProperty {
    return reflection.isInstance(item, RoleTargetProperty.$type);
}

export interface RoutingDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'RoutingDeclaration';
    value: RoutingValue;
}

export const RoutingDeclaration = {
    $type: 'RoutingDeclaration',
    value: 'value'
} as const;

export function isRoutingDeclaration(item: unknown): item is RoutingDeclaration {
    return reflection.isInstance(item, RoutingDeclaration.$type);
}

export interface RoutingProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'RoutingProperty';
    value: RoutingValue;
}

export const RoutingProperty = {
    $type: 'RoutingProperty',
    value: 'value'
} as const;

export function isRoutingProperty(item: unknown): item is RoutingProperty {
    return reflection.isInstance(item, RoutingProperty.$type);
}

export type RoutingValue = 'orthogonal' | 'polyline' | 'splines' | 'straight';

export function isRoutingValue(item: unknown): item is RoutingValue {
    return item === 'orthogonal' || item === 'polyline' || item === 'splines' || item === 'straight';
}

export interface SequenceActivateProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceActivateProperty';
    value: BooleanValue;
}

export const SequenceActivateProperty = {
    $type: 'SequenceActivateProperty',
    value: 'value'
} as const;

export function isSequenceActivateProperty(item: unknown): item is SequenceActivateProperty {
    return reflection.isInstance(item, SequenceActivateProperty.$type);
}

export interface SequenceAlternativeDecl extends langium.AstNode {
    readonly $container: SequenceFragmentAlternativesProperty;
    readonly $type: 'SequenceAlternativeDecl';
    fromMsg: string;
    label: string;
    toMsg: string;
}

export const SequenceAlternativeDecl = {
    $type: 'SequenceAlternativeDecl',
    fromMsg: 'fromMsg',
    label: 'label',
    toMsg: 'toMsg'
} as const;

export function isSequenceAlternativeDecl(item: unknown): item is SequenceAlternativeDecl {
    return reflection.isInstance(item, SequenceAlternativeDecl.$type);
}

export type SequenceDurationConstraintProperty = SequenceDurationConstraintValueProperty | SequenceDurationFromProperty | SequenceDurationToProperty;

export const SequenceDurationConstraintProperty = {
    $type: 'SequenceDurationConstraintProperty'
} as const;

export function isSequenceDurationConstraintProperty(item: unknown): item is SequenceDurationConstraintProperty {
    return reflection.isInstance(item, SequenceDurationConstraintProperty.$type);
}

export interface SequenceDurationConstraintStatement extends langium.AstNode {
    readonly $container: SequenceProfile;
    readonly $type: 'SequenceDurationConstraintStatement';
    properties: Array<SequenceDurationConstraintProperty>;
}

export const SequenceDurationConstraintStatement = {
    $type: 'SequenceDurationConstraintStatement',
    properties: 'properties'
} as const;

export function isSequenceDurationConstraintStatement(item: unknown): item is SequenceDurationConstraintStatement {
    return reflection.isInstance(item, SequenceDurationConstraintStatement.$type);
}

export interface SequenceDurationConstraintValueProperty extends langium.AstNode {
    readonly $container: SequenceDurationConstraintStatement;
    readonly $type: 'SequenceDurationConstraintValueProperty';
    constraint: string;
}

export const SequenceDurationConstraintValueProperty = {
    $type: 'SequenceDurationConstraintValueProperty',
    constraint: 'constraint'
} as const;

export function isSequenceDurationConstraintValueProperty(item: unknown): item is SequenceDurationConstraintValueProperty {
    return reflection.isInstance(item, SequenceDurationConstraintValueProperty.$type);
}

export interface SequenceDurationFromProperty extends langium.AstNode {
    readonly $container: SequenceDurationConstraintStatement;
    readonly $type: 'SequenceDurationFromProperty';
    from: string;
}

export const SequenceDurationFromProperty = {
    $type: 'SequenceDurationFromProperty',
    from: 'from'
} as const;

export function isSequenceDurationFromProperty(item: unknown): item is SequenceDurationFromProperty {
    return reflection.isInstance(item, SequenceDurationFromProperty.$type);
}

export interface SequenceDurationToProperty extends langium.AstNode {
    readonly $container: SequenceDurationConstraintStatement;
    readonly $type: 'SequenceDurationToProperty';
    to: string;
}

export const SequenceDurationToProperty = {
    $type: 'SequenceDurationToProperty',
    to: 'to'
} as const;

export function isSequenceDurationToProperty(item: unknown): item is SequenceDurationToProperty {
    return reflection.isInstance(item, SequenceDurationToProperty.$type);
}

export interface SequenceFragmentAlternativesProperty extends langium.AstNode {
    readonly $container: SequenceFragmentStatement;
    readonly $type: 'SequenceFragmentAlternativesProperty';
    alternatives: Array<SequenceAlternativeDecl>;
}

export const SequenceFragmentAlternativesProperty = {
    $type: 'SequenceFragmentAlternativesProperty',
    alternatives: 'alternatives'
} as const;

export function isSequenceFragmentAlternativesProperty(item: unknown): item is SequenceFragmentAlternativesProperty {
    return reflection.isInstance(item, SequenceFragmentAlternativesProperty.$type);
}

export interface SequenceFragmentFromProperty extends langium.AstNode {
    readonly $container: SequenceFragmentStatement;
    readonly $type: 'SequenceFragmentFromProperty';
    from: string;
}

export const SequenceFragmentFromProperty = {
    $type: 'SequenceFragmentFromProperty',
    from: 'from'
} as const;

export function isSequenceFragmentFromProperty(item: unknown): item is SequenceFragmentFromProperty {
    return reflection.isInstance(item, SequenceFragmentFromProperty.$type);
}

export interface SequenceFragmentGatesProperty extends langium.AstNode {
    readonly $container: SequenceFragmentStatement;
    readonly $type: 'SequenceFragmentGatesProperty';
    gates: Array<string>;
}

export const SequenceFragmentGatesProperty = {
    $type: 'SequenceFragmentGatesProperty',
    gates: 'gates'
} as const;

export function isSequenceFragmentGatesProperty(item: unknown): item is SequenceFragmentGatesProperty {
    return reflection.isInstance(item, SequenceFragmentGatesProperty.$type);
}

export type SequenceFragmentProperty = SequenceFragmentAlternativesProperty | SequenceFragmentFromProperty | SequenceFragmentGatesProperty | SequenceFragmentReferenceProperty | SequenceFragmentToProperty;

export const SequenceFragmentProperty = {
    $type: 'SequenceFragmentProperty'
} as const;

export function isSequenceFragmentProperty(item: unknown): item is SequenceFragmentProperty {
    return reflection.isInstance(item, SequenceFragmentProperty.$type);
}

export interface SequenceFragmentReferenceProperty extends langium.AstNode {
    readonly $container: SequenceFragmentStatement;
    readonly $type: 'SequenceFragmentReferenceProperty';
    ref: string;
}

export const SequenceFragmentReferenceProperty = {
    $type: 'SequenceFragmentReferenceProperty',
    ref: 'ref'
} as const;

export function isSequenceFragmentReferenceProperty(item: unknown): item is SequenceFragmentReferenceProperty {
    return reflection.isInstance(item, SequenceFragmentReferenceProperty.$type);
}

export interface SequenceFragmentStatement extends langium.AstNode {
    readonly $container: SequenceProfile;
    readonly $type: 'SequenceFragmentStatement';
    label: string;
    properties: Array<SequenceFragmentProperty>;
    type: SequenceFragmentType;
}

export const SequenceFragmentStatement = {
    $type: 'SequenceFragmentStatement',
    label: 'label',
    properties: 'properties',
    type: 'type'
} as const;

export function isSequenceFragmentStatement(item: unknown): item is SequenceFragmentStatement {
    return reflection.isInstance(item, SequenceFragmentStatement.$type);
}

export interface SequenceFragmentToProperty extends langium.AstNode {
    readonly $container: SequenceFragmentStatement;
    readonly $type: 'SequenceFragmentToProperty';
    to: string;
}

export const SequenceFragmentToProperty = {
    $type: 'SequenceFragmentToProperty',
    to: 'to'
} as const;

export function isSequenceFragmentToProperty(item: unknown): item is SequenceFragmentToProperty {
    return reflection.isInstance(item, SequenceFragmentToProperty.$type);
}

export type SequenceFragmentType = 'alt' | 'break' | 'critical' | 'loop' | 'opt' | 'par' | 'ref';

export function isSequenceFragmentType(item: unknown): item is SequenceFragmentType {
    return item === 'loop' || item === 'alt' || item === 'opt' || item === 'par' || item === 'critical' || item === 'break' || item === 'ref';
}

export interface SequenceFromProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceFromProperty';
    from: 'found' | 'lost' | string;
}

export const SequenceFromProperty = {
    $type: 'SequenceFromProperty',
    from: 'from'
} as const;

export function isSequenceFromProperty(item: unknown): item is SequenceFromProperty {
    return reflection.isInstance(item, SequenceFromProperty.$type);
}

export interface SequenceGuardProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceGuardProperty';
    value: string;
}

export const SequenceGuardProperty = {
    $type: 'SequenceGuardProperty',
    value: 'value'
} as const;

export function isSequenceGuardProperty(item: unknown): item is SequenceGuardProperty {
    return reflection.isInstance(item, SequenceGuardProperty.$type);
}

export interface SequenceLabelProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceLabelProperty';
    label: string;
}

export const SequenceLabelProperty = {
    $type: 'SequenceLabelProperty',
    label: 'label'
} as const;

export function isSequenceLabelProperty(item: unknown): item is SequenceLabelProperty {
    return reflection.isInstance(item, SequenceLabelProperty.$type);
}

export type SequenceMessageProperty = SequenceActivateProperty | SequenceFromProperty | SequenceGuardProperty | SequenceLabelProperty | SequenceStateInvariantProperty | SequenceTimingProperty | SequenceToProperty | SequenceTypeProperty;

export const SequenceMessageProperty = {
    $type: 'SequenceMessageProperty'
} as const;

export function isSequenceMessageProperty(item: unknown): item is SequenceMessageProperty {
    return reflection.isInstance(item, SequenceMessageProperty.$type);
}

export interface SequenceMessageStatement extends langium.AstNode {
    readonly $container: SequenceProfile;
    readonly $type: 'SequenceMessageStatement';
    properties: Array<SequenceMessageProperty>;
}

export const SequenceMessageStatement = {
    $type: 'SequenceMessageStatement',
    properties: 'properties'
} as const;

export function isSequenceMessageStatement(item: unknown): item is SequenceMessageStatement {
    return reflection.isInstance(item, SequenceMessageStatement.$type);
}

export type SequenceMessageType = 'async' | 'create' | 'destroy' | 'return' | 'sync';

export function isSequenceMessageType(item: unknown): item is SequenceMessageType {
    return item === 'sync' || item === 'async' || item === 'return' || item === 'create' || item === 'destroy';
}

export interface SequenceNoteParticipantsProperty extends langium.AstNode {
    readonly $container: SequenceNoteStatement;
    readonly $type: 'SequenceNoteParticipantsProperty';
    participants: Array<string>;
}

export const SequenceNoteParticipantsProperty = {
    $type: 'SequenceNoteParticipantsProperty',
    participants: 'participants'
} as const;

export function isSequenceNoteParticipantsProperty(item: unknown): item is SequenceNoteParticipantsProperty {
    return reflection.isInstance(item, SequenceNoteParticipantsProperty.$type);
}

export type SequenceNotePosition = 'left' | 'over' | 'right';

export function isSequenceNotePosition(item: unknown): item is SequenceNotePosition {
    return item === 'left' || item === 'right' || item === 'over';
}

export interface SequenceNotePositionProperty extends langium.AstNode {
    readonly $container: SequenceNoteStatement;
    readonly $type: 'SequenceNotePositionProperty';
    position: SequenceNotePosition;
}

export const SequenceNotePositionProperty = {
    $type: 'SequenceNotePositionProperty',
    position: 'position'
} as const;

export function isSequenceNotePositionProperty(item: unknown): item is SequenceNotePositionProperty {
    return reflection.isInstance(item, SequenceNotePositionProperty.$type);
}

export type SequenceNoteProperty = SequenceNoteParticipantsProperty | SequenceNotePositionProperty;

export const SequenceNoteProperty = {
    $type: 'SequenceNoteProperty'
} as const;

export function isSequenceNoteProperty(item: unknown): item is SequenceNoteProperty {
    return reflection.isInstance(item, SequenceNoteProperty.$type);
}

export interface SequenceNoteStatement extends langium.AstNode {
    readonly $container: SequenceProfile;
    readonly $type: 'SequenceNoteStatement';
    properties: Array<SequenceNoteProperty>;
    text: string;
}

export const SequenceNoteStatement = {
    $type: 'SequenceNoteStatement',
    properties: 'properties',
    text: 'text'
} as const;

export function isSequenceNoteStatement(item: unknown): item is SequenceNoteStatement {
    return reflection.isInstance(item, SequenceNoteStatement.$type);
}

export interface SequenceParticipantStatement extends langium.AstNode {
    readonly $container: SequenceProfile;
    readonly $type: 'SequenceParticipantStatement';
    name: string;
    type?: SequenceParticipantType;
}

export const SequenceParticipantStatement = {
    $type: 'SequenceParticipantStatement',
    name: 'name',
    type: 'type'
} as const;

export function isSequenceParticipantStatement(item: unknown): item is SequenceParticipantStatement {
    return reflection.isInstance(item, SequenceParticipantStatement.$type);
}

export type SequenceParticipantType = 'actor' | 'boundary' | 'continuation' | 'control' | 'database' | 'entity';

export function isSequenceParticipantType(item: unknown): item is SequenceParticipantType {
    return item === 'actor' || item === 'entity' || item === 'boundary' || item === 'control' || item === 'database' || item === 'continuation';
}

export interface SequenceProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'SequenceProfile';
    name: string;
    statements: Array<SequenceStatement>;
}

export const SequenceProfile = {
    $type: 'SequenceProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isSequenceProfile(item: unknown): item is SequenceProfile {
    return reflection.isInstance(item, SequenceProfile.$type);
}

export interface SequenceStateInvariantProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceStateInvariantProperty';
    value: string;
}

export const SequenceStateInvariantProperty = {
    $type: 'SequenceStateInvariantProperty',
    value: 'value'
} as const;

export function isSequenceStateInvariantProperty(item: unknown): item is SequenceStateInvariantProperty {
    return reflection.isInstance(item, SequenceStateInvariantProperty.$type);
}

export type SequenceStatement = SequenceDurationConstraintStatement | SequenceFragmentStatement | SequenceMessageStatement | SequenceNoteStatement | SequenceParticipantStatement;

export const SequenceStatement = {
    $type: 'SequenceStatement'
} as const;

export function isSequenceStatement(item: unknown): item is SequenceStatement {
    return reflection.isInstance(item, SequenceStatement.$type);
}

export interface SequenceTimingProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceTimingProperty';
    value: string;
}

export const SequenceTimingProperty = {
    $type: 'SequenceTimingProperty',
    value: 'value'
} as const;

export function isSequenceTimingProperty(item: unknown): item is SequenceTimingProperty {
    return reflection.isInstance(item, SequenceTimingProperty.$type);
}

export interface SequenceToProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceToProperty';
    to: 'found' | 'lost' | string;
}

export const SequenceToProperty = {
    $type: 'SequenceToProperty',
    to: 'to'
} as const;

export function isSequenceToProperty(item: unknown): item is SequenceToProperty {
    return reflection.isInstance(item, SequenceToProperty.$type);
}

export interface SequenceTypeProperty extends langium.AstNode {
    readonly $container: SequenceMessageStatement;
    readonly $type: 'SequenceTypeProperty';
    type: SequenceMessageType;
}

export const SequenceTypeProperty = {
    $type: 'SequenceTypeProperty',
    type: 'type'
} as const;

export function isSequenceTypeProperty(item: unknown): item is SequenceTypeProperty {
    return reflection.isInstance(item, SequenceTypeProperty.$type);
}

export interface ShapeDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'ShapeDeclaration';
    id: FlexibleID;
    properties: Array<NodeProperty>;
    shape?: ShapeIdentifier;
}

export const ShapeDeclaration = {
    $type: 'ShapeDeclaration',
    id: 'id',
    properties: 'properties',
    shape: 'shape'
} as const;

export function isShapeDeclaration(item: unknown): item is ShapeDeclaration {
    return reflection.isInstance(item, ShapeDeclaration.$type);
}

export type ShapeIdentifier = 'acceptEvent' | 'activity' | 'activityFinal' | 'actor' | 'artifact' | 'assembly' | 'boundary' | 'centralBuffer' | 'circle' | 'collaboration' | 'component' | 'continuation' | 'control' | 'dataStore' | 'database' | 'db' | 'entity' | 'entryPoint' | 'exitPoint' | 'finalState' | 'flowFinal' | 'frame' | 'history' | 'historyDeep' | 'historyShallow' | 'initialState' | 'junction' | 'lifeline' | 'loop' | 'module' | 'node' | 'note' | 'objectNode' | 'person' | 'pill' | 'pin' | 'port' | 'providedInterface' | 'receiveSignal' | 'requiredInterface' | 'sendSignal' | 'submachine' | 'template' | 'terminate' | 'timeObservation' | 'verticalFork' | string;

export function isShapeIdentifier(item: unknown): item is ShapeIdentifier {
    return item === 'actor' || item === 'entity' || item === 'boundary' || item === 'control' || item === 'database' || item === 'note' || item === 'lifeline' || item === 'continuation' || item === 'timeObservation' || item === 'activity' || item === 'objectNode' || item === 'centralBuffer' || item === 'dataStore' || item === 'component' || item === 'artifact' || item === 'node' || item === 'port' || item === 'module' || item === 'template' || item === 'history' || item === 'pin' || item === 'assembly' || item === 'providedInterface' || item === 'requiredInterface' || item === 'frame' || item === 'collaboration' || item === 'submachine' || item === 'loop' || item === 'verticalFork' || item === 'sendSignal' || item === 'receiveSignal' || item === 'acceptEvent' || item === 'activityFinal' || item === 'flowFinal' || item === 'initialState' || item === 'finalState' || item === 'historyShallow' || item === 'historyDeep' || item === 'junction' || item === 'entryPoint' || item === 'exitPoint' || item === 'terminate' || item === 'db' || item === 'pill' || item === 'circle' || item === 'person' || (typeof item === 'string' && (/[a-z_][a-zA-Z0-9_]*-[a-zA-Z0-9_-]*/.test(item) || /[a-zA-Z_][a-zA-Z0-9_]*/.test(item)));
}

export interface ShowLegendProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ShowLegendProperty';
    value: BooleanValue;
}

export const ShowLegendProperty = {
    $type: 'ShowLegendProperty',
    value: 'value'
} as const;

export function isShowLegendProperty(item: unknown): item is ShowLegendProperty {
    return reflection.isInstance(item, ShowLegendProperty.$type);
}

export interface ShowMetricsProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ShowMetricsProperty';
    value: BooleanValue;
}

export const ShowMetricsProperty = {
    $type: 'ShowMetricsProperty',
    value: 'value'
} as const;

export function isShowMetricsProperty(item: unknown): item is ShowMetricsProperty {
    return reflection.isInstance(item, ShowMetricsProperty.$type);
}

export interface ShowValuesProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'ShowValuesProperty';
    value: BooleanValue;
}

export const ShowValuesProperty = {
    $type: 'ShowValuesProperty',
    value: 'value'
} as const;

export function isShowValuesProperty(item: unknown): item is ShowValuesProperty {
    return reflection.isInstance(item, ShowValuesProperty.$type);
}

export type SizeUnit = 'DN' | 'NPS' | 'in' | 'mm';

export function isSizeUnit(item: unknown): item is SizeUnit {
    return item === 'in' || item === 'mm' || item === 'NPS' || item === 'DN';
}

export interface StackedProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'StackedProperty';
    value: BooleanValue;
}

export const StackedProperty = {
    $type: 'StackedProperty',
    value: 'value'
} as const;

export function isStackedProperty(item: unknown): item is StackedProperty {
    return reflection.isInstance(item, StackedProperty.$type);
}

export interface StateInvariantProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'StateInvariantProperty';
    value: string;
}

export const StateInvariantProperty = {
    $type: 'StateInvariantProperty',
    value: 'value'
} as const;

export function isStateInvariantProperty(item: unknown): item is StateInvariantProperty {
    return reflection.isInstance(item, StateInvariantProperty.$type);
}

export interface StereotypeProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration | ShapeDeclaration;
    readonly $type: 'StereotypeProperty';
    value?: string;
    values: Array<string>;
}

export const StereotypeProperty = {
    $type: 'StereotypeProperty',
    value: 'value',
    values: 'values'
} as const;

export function isStereotypeProperty(item: unknown): item is StereotypeProperty {
    return reflection.isInstance(item, StereotypeProperty.$type);
}

export interface StringArray extends langium.AstNode {
    readonly $container: ColorsProperty | ExtensionPointsProperty | InputPinsProperty | IntersectionsProperty | LabelsProperty | OutputPinsProperty;
    readonly $type: 'StringArray';
    items: Array<string>;
}

export const StringArray = {
    $type: 'StringArray',
    items: 'items'
} as const;

export function isStringArray(item: unknown): item is StringArray {
    return reflection.isInstance(item, StringArray.$type);
}

export interface StrokeColorProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration | ShapeDeclaration;
    readonly $type: 'StrokeColorProperty';
    value: string;
}

export const StrokeColorProperty = {
    $type: 'StrokeColorProperty',
    value: 'value'
} as const;

export function isStrokeColorProperty(item: unknown): item is StrokeColorProperty {
    return reflection.isInstance(item, StrokeColorProperty.$type);
}

export interface StrokeWidthProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration | ShapeDeclaration;
    readonly $type: 'StrokeWidthProperty';
    value: string;
}

export const StrokeWidthProperty = {
    $type: 'StrokeWidthProperty',
    value: 'value'
} as const;

export function isStrokeWidthProperty(item: unknown): item is StrokeWidthProperty {
    return reflection.isInstance(item, StrokeWidthProperty.$type);
}

export interface StyleDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'StyleDeclaration';
    name: string;
    properties: Array<StyleProperty>;
}

export const StyleDeclaration = {
    $type: 'StyleDeclaration',
    name: 'name',
    properties: 'properties'
} as const;

export function isStyleDeclaration(item: unknown): item is StyleDeclaration {
    return reflection.isInstance(item, StyleDeclaration.$type);
}

export interface StyleProperty extends langium.AstNode {
    readonly $container: StyleDeclaration;
    readonly $type: 'StyleProperty';
    key: StylePropertyKey;
    value: string;
}

export const StyleProperty = {
    $type: 'StyleProperty',
    key: 'key',
    value: 'value'
} as const;

export function isStyleProperty(item: unknown): item is StyleProperty {
    return reflection.isInstance(item, StyleProperty.$type);
}

export type StylePropertyKey = string;

export function isStylePropertyKey(item: unknown): item is StylePropertyKey {
    return typeof item === 'string';
}

export interface StyleRefProperty extends langium.AstNode {
    readonly $container: ContainerBlock | EdgeDeclaration | ShapeDeclaration;
    readonly $type: 'StyleRefProperty';
    ref: langium.Reference<StyleDeclaration>;
}

export const StyleRefProperty = {
    $type: 'StyleRefProperty',
    ref: 'ref'
} as const;

export function isStyleRefProperty(item: unknown): item is StyleRefProperty {
    return reflection.isInstance(item, StyleRefProperty.$type);
}

export interface TemplateBlock extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'TemplateBlock';
    children: Array<string>;
    description?: string;
    id: string;
    label?: string;
    parameters: Array<TemplateParameter>;
    properties: Array<ContainerStyleProperty>;
}

export const TemplateBlock = {
    $type: 'TemplateBlock',
    children: 'children',
    description: 'description',
    id: 'id',
    label: 'label',
    parameters: 'parameters',
    properties: 'properties'
} as const;

export function isTemplateBlock(item: unknown): item is TemplateBlock {
    return reflection.isInstance(item, TemplateBlock.$type);
}

export interface TemplateDataProperty extends langium.AstNode {
    readonly $container: TemplateNodeProperty;
    readonly $type: 'TemplateDataProperty';
    key: TemplateIdentifier;
    value: TemplateExpression;
}

export const TemplateDataProperty = {
    $type: 'TemplateDataProperty',
    key: 'key',
    value: 'value'
} as const;

export function isTemplateDataProperty(item: unknown): item is TemplateDataProperty {
    return reflection.isInstance(item, TemplateDataProperty.$type);
}

export interface TemplateEdgeDeclaration extends langium.AstNode {
    readonly $container: ConditionalBlock | ForEachBlock | LoopBlock;
    readonly $type: 'TemplateEdgeDeclaration';
    from: TemplateExpression;
    properties: Array<TemplateEdgeProperty>;
    to: TemplateExpression;
}

export const TemplateEdgeDeclaration = {
    $type: 'TemplateEdgeDeclaration',
    from: 'from',
    properties: 'properties',
    to: 'to'
} as const;

export function isTemplateEdgeDeclaration(item: unknown): item is TemplateEdgeDeclaration {
    return reflection.isInstance(item, TemplateEdgeDeclaration.$type);
}

export interface TemplateEdgeProperty extends langium.AstNode {
    readonly $container: TemplateEdgeDeclaration;
    readonly $type: 'TemplateEdgeProperty';
    condition?: TemplateExpression;
    label?: TemplateExpression;
    style?: string;
}

export const TemplateEdgeProperty = {
    $type: 'TemplateEdgeProperty',
    condition: 'condition',
    label: 'label',
    style: 'style'
} as const;

export function isTemplateEdgeProperty(item: unknown): item is TemplateEdgeProperty {
    return reflection.isInstance(item, TemplateEdgeProperty.$type);
}

export interface TemplateExpression extends langium.AstNode {
    readonly $container: ConditionalBlock | LoopBlock | TemplateDataProperty | TemplateEdgeDeclaration | TemplateEdgeProperty | TemplateNodeDeclaration | TemplateNodeProperty;
    readonly $type: 'TemplateExpression';
    parts: Array<TemplateExpressionPart>;
}

export const TemplateExpression = {
    $type: 'TemplateExpression',
    parts: 'parts'
} as const;

export function isTemplateExpression(item: unknown): item is TemplateExpression {
    return reflection.isInstance(item, TemplateExpression.$type);
}

export type TemplateExpressionPart = TemplateLiteral | TemplateVariable;

export const TemplateExpressionPart = {
    $type: 'TemplateExpressionPart'
} as const;

export function isTemplateExpressionPart(item: unknown): item is TemplateExpressionPart {
    return reflection.isInstance(item, TemplateExpressionPart.$type);
}

export type TemplateIdentifier = 'color' | 'data' | 'delimiter' | 'filter' | 'format' | 'from' | 'header' | 'id' | 'item' | 'key' | 'label' | 'limit' | 'name' | 'source' | 'to' | 'type' | 'value' | string;

export function isTemplateIdentifier(item: unknown): item is TemplateIdentifier {
    return item === 'data' || item === 'color' || item === 'header' || item === 'delimiter' || item === 'value' || item === 'type' || item === 'from' || item === 'to' || item === 'label' || item === 'name' || item === 'id' || item === 'key' || item === 'format' || item === 'source' || item === 'filter' || item === 'limit' || item === 'item' || (typeof item === 'string' && (/[a-zA-Z_][a-zA-Z0-9_]*/.test(item)));
}

export interface TemplateLiteral extends langium.AstNode {
    readonly $container: TemplateExpression;
    readonly $type: 'TemplateLiteral';
    value: string;
}

export const TemplateLiteral = {
    $type: 'TemplateLiteral',
    value: 'value'
} as const;

export function isTemplateLiteral(item: unknown): item is TemplateLiteral {
    return reflection.isInstance(item, TemplateLiteral.$type);
}

export interface TemplateNodeDeclaration extends langium.AstNode {
    readonly $container: ConditionalBlock | ForEachBlock | LoopBlock;
    readonly $type: 'TemplateNodeDeclaration';
    id: TemplateExpression;
    properties: Array<TemplateNodeProperty>;
}

export const TemplateNodeDeclaration = {
    $type: 'TemplateNodeDeclaration',
    id: 'id',
    properties: 'properties'
} as const;

export function isTemplateNodeDeclaration(item: unknown): item is TemplateNodeDeclaration {
    return reflection.isInstance(item, TemplateNodeDeclaration.$type);
}

export interface TemplateNodeProperty extends langium.AstNode {
    readonly $container: TemplateNodeDeclaration;
    readonly $type: 'TemplateNodeProperty';
    dataProps: Array<TemplateDataProperty>;
    fillColor?: TemplateExpression;
    label?: TemplateExpression;
    shape?: string;
    strokeColor?: TemplateExpression;
    style?: string;
}

export const TemplateNodeProperty = {
    $type: 'TemplateNodeProperty',
    dataProps: 'dataProps',
    fillColor: 'fillColor',
    label: 'label',
    shape: 'shape',
    strokeColor: 'strokeColor',
    style: 'style'
} as const;

export function isTemplateNodeProperty(item: unknown): item is TemplateNodeProperty {
    return reflection.isInstance(item, TemplateNodeProperty.$type);
}

export interface TemplateParameter extends langium.AstNode {
    readonly $container: TemplateBlock;
    readonly $type: 'TemplateParameter';
    defaultValue?: BooleanValue | string;
    name: string;
    type: TemplateParameterType;
}

export const TemplateParameter = {
    $type: 'TemplateParameter',
    defaultValue: 'defaultValue',
    name: 'name',
    type: 'type'
} as const;

export function isTemplateParameter(item: unknown): item is TemplateParameter {
    return reflection.isInstance(item, TemplateParameter.$type);
}

export type TemplateParameterType = 'boolean' | 'color' | 'number' | 'string';

export function isTemplateParameterType(item: unknown): item is TemplateParameterType {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'color';
}

export type TemplateStatement = ConditionalBlock | LoopBlock | TemplateEdgeDeclaration | TemplateNodeDeclaration;

export const TemplateStatement = {
    $type: 'TemplateStatement'
} as const;

export function isTemplateStatement(item: unknown): item is TemplateStatement {
    return reflection.isInstance(item, TemplateStatement.$type);
}

export interface TemplateVariable extends langium.AstNode {
    readonly $container: TemplateExpression;
    readonly $type: 'TemplateVariable';
    path: TemplateVariablePath;
}

export const TemplateVariable = {
    $type: 'TemplateVariable',
    path: 'path'
} as const;

export function isTemplateVariable(item: unknown): item is TemplateVariable {
    return reflection.isInstance(item, TemplateVariable.$type);
}

export interface TemplateVariablePath extends langium.AstNode {
    readonly $container: TemplateVariable;
    readonly $type: 'TemplateVariablePath';
    segments: Array<TemplateIdentifier>;
}

export const TemplateVariablePath = {
    $type: 'TemplateVariablePath',
    segments: 'segments'
} as const;

export function isTemplateVariablePath(item: unknown): item is TemplateVariablePath {
    return reflection.isInstance(item, TemplateVariablePath.$type);
}

export type TempUnit = 'K' | 'degC' | 'degF';

export function isTempUnit(item: unknown): item is TempUnit {
    return item === 'degC' || item === 'degF' || item === 'K';
}

export interface TextAlignProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'TextAlignProperty';
    value: TextAlignValue;
}

export const TextAlignProperty = {
    $type: 'TextAlignProperty',
    value: 'value'
} as const;

export function isTextAlignProperty(item: unknown): item is TextAlignProperty {
    return reflection.isInstance(item, TextAlignProperty.$type);
}

export type TextAlignValue = 'center' | 'left' | 'right';

export function isTextAlignValue(item: unknown): item is TextAlignValue {
    return item === 'left' || item === 'center' || item === 'right';
}

export interface TextColorProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'TextColorProperty';
    value: string;
}

export const TextColorProperty = {
    $type: 'TextColorProperty',
    value: 'value'
} as const;

export function isTextColorProperty(item: unknown): item is TextColorProperty {
    return reflection.isInstance(item, TextColorProperty.$type);
}

export interface ThemeDeclaration extends langium.AstNode {
    readonly $container: ContainerBlock | DiagramProfile | GroupBlock;
    readonly $type: 'ThemeDeclaration';
    value: ThemeValue;
}

export const ThemeDeclaration = {
    $type: 'ThemeDeclaration',
    value: 'value'
} as const;

export function isThemeDeclaration(item: unknown): item is ThemeDeclaration {
    return reflection.isInstance(item, ThemeDeclaration.$type);
}

export type ThemeValue = 'colorful' | 'cool' | 'forest' | 'monochrome' | 'ocean' | 'professional' | 'runiq' | 'sunset' | 'vibrant' | 'warm';

export function isThemeValue(item: unknown): item is ThemeValue {
    return item === 'professional' || item === 'forest' || item === 'sunset' || item === 'ocean' || item === 'monochrome' || item === 'colorful' || item === 'vibrant' || item === 'warm' || item === 'cool' || item === 'runiq';
}

export interface TimelineColorProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement | TimelinePeriodStatement;
    readonly $type: 'TimelineColorProperty';
    color: string;
}

export const TimelineColorProperty = {
    $type: 'TimelineColorProperty',
    color: 'color'
} as const;

export function isTimelineColorProperty(item: unknown): item is TimelineColorProperty {
    return reflection.isInstance(item, TimelineColorProperty.$type);
}

export interface TimelineDateProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement;
    readonly $type: 'TimelineDateProperty';
    date: string;
}

export const TimelineDateProperty = {
    $type: 'TimelineDateProperty',
    date: 'date'
} as const;

export function isTimelineDateProperty(item: unknown): item is TimelineDateProperty {
    return reflection.isInstance(item, TimelineDateProperty.$type);
}

export interface TimelineDescriptionProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement;
    readonly $type: 'TimelineDescriptionProperty';
    description: string;
}

export const TimelineDescriptionProperty = {
    $type: 'TimelineDescriptionProperty',
    description: 'description'
} as const;

export function isTimelineDescriptionProperty(item: unknown): item is TimelineDescriptionProperty {
    return reflection.isInstance(item, TimelineDescriptionProperty.$type);
}

export interface TimelineEndDateProperty extends langium.AstNode {
    readonly $container: TimelinePeriodStatement;
    readonly $type: 'TimelineEndDateProperty';
    endDate: string;
}

export const TimelineEndDateProperty = {
    $type: 'TimelineEndDateProperty',
    endDate: 'endDate'
} as const;

export function isTimelineEndDateProperty(item: unknown): item is TimelineEndDateProperty {
    return reflection.isInstance(item, TimelineEndDateProperty.$type);
}

export type TimelineEventProperty = TimelineColorProperty | TimelineDateProperty | TimelineDescriptionProperty | TimelineIconProperty | TimelineLabelProperty | TimelinePositionProperty;

export const TimelineEventProperty = {
    $type: 'TimelineEventProperty'
} as const;

export function isTimelineEventProperty(item: unknown): item is TimelineEventProperty {
    return reflection.isInstance(item, TimelineEventProperty.$type);
}

export interface TimelineEventStatement extends langium.AstNode {
    readonly $container: TimelineProfile;
    readonly $type: 'TimelineEventStatement';
    id: string;
    properties: Array<TimelineEventProperty>;
}

export const TimelineEventStatement = {
    $type: 'TimelineEventStatement',
    id: 'id',
    properties: 'properties'
} as const;

export function isTimelineEventStatement(item: unknown): item is TimelineEventStatement {
    return reflection.isInstance(item, TimelineEventStatement.$type);
}

export interface TimelineIconProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement;
    readonly $type: 'TimelineIconProperty';
    icon: string;
}

export const TimelineIconProperty = {
    $type: 'TimelineIconProperty',
    icon: 'icon'
} as const;

export function isTimelineIconProperty(item: unknown): item is TimelineIconProperty {
    return reflection.isInstance(item, TimelineIconProperty.$type);
}

export interface TimelineLabelProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement | TimelinePeriodStatement;
    readonly $type: 'TimelineLabelProperty';
    label: string;
}

export const TimelineLabelProperty = {
    $type: 'TimelineLabelProperty',
    label: 'label'
} as const;

export function isTimelineLabelProperty(item: unknown): item is TimelineLabelProperty {
    return reflection.isInstance(item, TimelineLabelProperty.$type);
}

export interface TimelineOpacityProperty extends langium.AstNode {
    readonly $container: TimelinePeriodStatement;
    readonly $type: 'TimelineOpacityProperty';
    opacity: string;
}

export const TimelineOpacityProperty = {
    $type: 'TimelineOpacityProperty',
    opacity: 'opacity'
} as const;

export function isTimelineOpacityProperty(item: unknown): item is TimelineOpacityProperty {
    return reflection.isInstance(item, TimelineOpacityProperty.$type);
}

export type TimelineOrientation = 'horizontal' | 'vertical';

export function isTimelineOrientation(item: unknown): item is TimelineOrientation {
    return item === 'horizontal' || item === 'vertical';
}

export interface TimelineOrientationStatement extends langium.AstNode {
    readonly $container: TimelineProfile;
    readonly $type: 'TimelineOrientationStatement';
    orientation: TimelineOrientation;
}

export const TimelineOrientationStatement = {
    $type: 'TimelineOrientationStatement',
    orientation: 'orientation'
} as const;

export function isTimelineOrientationStatement(item: unknown): item is TimelineOrientationStatement {
    return reflection.isInstance(item, TimelineOrientationStatement.$type);
}

export type TimelinePeriodProperty = TimelineColorProperty | TimelineEndDateProperty | TimelineLabelProperty | TimelineOpacityProperty | TimelineStartDateProperty;

export const TimelinePeriodProperty = {
    $type: 'TimelinePeriodProperty'
} as const;

export function isTimelinePeriodProperty(item: unknown): item is TimelinePeriodProperty {
    return reflection.isInstance(item, TimelinePeriodProperty.$type);
}

export interface TimelinePeriodStatement extends langium.AstNode {
    readonly $container: TimelineProfile;
    readonly $type: 'TimelinePeriodStatement';
    id: string;
    properties: Array<TimelinePeriodProperty>;
}

export const TimelinePeriodStatement = {
    $type: 'TimelinePeriodStatement',
    id: 'id',
    properties: 'properties'
} as const;

export function isTimelinePeriodStatement(item: unknown): item is TimelinePeriodStatement {
    return reflection.isInstance(item, TimelinePeriodStatement.$type);
}

export type TimelinePosition = 'bottom' | 'left' | 'right' | 'top';

export function isTimelinePosition(item: unknown): item is TimelinePosition {
    return item === 'top' || item === 'bottom' || item === 'left' || item === 'right';
}

export interface TimelinePositionProperty extends langium.AstNode {
    readonly $container: TimelineEventStatement;
    readonly $type: 'TimelinePositionProperty';
    position: TimelinePosition;
}

export const TimelinePositionProperty = {
    $type: 'TimelinePositionProperty',
    position: 'position'
} as const;

export function isTimelinePositionProperty(item: unknown): item is TimelinePositionProperty {
    return reflection.isInstance(item, TimelinePositionProperty.$type);
}

export interface TimelineProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'TimelineProfile';
    name: string;
    statements: Array<TimelineStatement>;
}

export const TimelineProfile = {
    $type: 'TimelineProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isTimelineProfile(item: unknown): item is TimelineProfile {
    return reflection.isInstance(item, TimelineProfile.$type);
}

export interface TimelineStartDateProperty extends langium.AstNode {
    readonly $container: TimelinePeriodStatement;
    readonly $type: 'TimelineStartDateProperty';
    startDate: string;
}

export const TimelineStartDateProperty = {
    $type: 'TimelineStartDateProperty',
    startDate: 'startDate'
} as const;

export function isTimelineStartDateProperty(item: unknown): item is TimelineStartDateProperty {
    return reflection.isInstance(item, TimelineStartDateProperty.$type);
}

export type TimelineStatement = TimelineEventStatement | TimelineOrientationStatement | TimelinePeriodStatement;

export const TimelineStatement = {
    $type: 'TimelineStatement'
} as const;

export function isTimelineStatement(item: unknown): item is TimelineStatement {
    return reflection.isInstance(item, TimelineStatement.$type);
}

export interface TitleProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'TitleProperty';
    value: string;
}

export const TitleProperty = {
    $type: 'TitleProperty',
    value: 'value'
} as const;

export function isTitleProperty(item: unknown): item is TitleProperty {
    return reflection.isInstance(item, TitleProperty.$type);
}

export interface TooltipProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'TooltipProperty';
    text: string;
}

export const TooltipProperty = {
    $type: 'TooltipProperty',
    text: 'text'
} as const;

export function isTooltipProperty(item: unknown): item is TooltipProperty {
    return reflection.isInstance(item, TooltipProperty.$type);
}

export type VerticalAlignValue = 'bottom' | 'middle' | 'top';

export function isVerticalAlignValue(item: unknown): item is VerticalAlignValue {
    return item === 'top' || item === 'middle' || item === 'bottom';
}

export type VisibilityValue = 'package' | 'private' | 'protected' | 'public';

export function isVisibilityValue(item: unknown): item is VisibilityValue {
    return item === 'public' || item === 'private' || item === 'protected' || item === 'package';
}

export type VolumeUnit = 'L' | 'bbl' | 'ft³' | 'gal' | 'm³';

export function isVolumeUnit(item: unknown): item is VolumeUnit {
    return item === 'L' || item === 'm³' || item === 'gal' || item === 'bbl' || item === 'ft³';
}

export type WardleyAnchorProperty = WardleyEvolutionProperty | WardleyValueProperty;

export const WardleyAnchorProperty = {
    $type: 'WardleyAnchorProperty'
} as const;

export function isWardleyAnchorProperty(item: unknown): item is WardleyAnchorProperty {
    return reflection.isInstance(item, WardleyAnchorProperty.$type);
}

export interface WardleyAnchorStatement extends langium.AstNode {
    readonly $container: WardleyProfile;
    readonly $type: 'WardleyAnchorStatement';
    name: string;
    properties: Array<WardleyAnchorProperty>;
}

export const WardleyAnchorStatement = {
    $type: 'WardleyAnchorStatement',
    name: 'name',
    properties: 'properties'
} as const;

export function isWardleyAnchorStatement(item: unknown): item is WardleyAnchorStatement {
    return reflection.isInstance(item, WardleyAnchorStatement.$type);
}

export type WardleyComponentProperty = WardleyEvolutionProperty | WardleyInertiaProperty | WardleyLabelProperty | WardleyValueProperty;

export const WardleyComponentProperty = {
    $type: 'WardleyComponentProperty'
} as const;

export function isWardleyComponentProperty(item: unknown): item is WardleyComponentProperty {
    return reflection.isInstance(item, WardleyComponentProperty.$type);
}

export interface WardleyComponentStatement extends langium.AstNode {
    readonly $container: WardleyProfile;
    readonly $type: 'WardleyComponentStatement';
    name: string;
    properties: Array<WardleyComponentProperty>;
}

export const WardleyComponentStatement = {
    $type: 'WardleyComponentStatement',
    name: 'name',
    properties: 'properties'
} as const;

export function isWardleyComponentStatement(item: unknown): item is WardleyComponentStatement {
    return reflection.isInstance(item, WardleyComponentStatement.$type);
}

export interface WardleyDependencyStatement extends langium.AstNode {
    readonly $container: WardleyProfile;
    readonly $type: 'WardleyDependencyStatement';
    from: string;
    to: string;
}

export const WardleyDependencyStatement = {
    $type: 'WardleyDependencyStatement',
    from: 'from',
    to: 'to'
} as const;

export function isWardleyDependencyStatement(item: unknown): item is WardleyDependencyStatement {
    return reflection.isInstance(item, WardleyDependencyStatement.$type);
}

export interface WardleyEvolutionProperty extends langium.AstNode {
    readonly $container: WardleyAnchorStatement | WardleyComponentStatement | WardleyEvolutionStatement;
    readonly $type: 'WardleyEvolutionProperty';
    value: string;
}

export const WardleyEvolutionProperty = {
    $type: 'WardleyEvolutionProperty',
    value: 'value'
} as const;

export function isWardleyEvolutionProperty(item: unknown): item is WardleyEvolutionProperty {
    return reflection.isInstance(item, WardleyEvolutionProperty.$type);
}

export interface WardleyEvolutionStatement extends langium.AstNode {
    readonly $container: WardleyProfile;
    readonly $type: 'WardleyEvolutionStatement';
    component: string;
    properties: Array<WardleyEvolutionProperty>;
}

export const WardleyEvolutionStatement = {
    $type: 'WardleyEvolutionStatement',
    component: 'component',
    properties: 'properties'
} as const;

export function isWardleyEvolutionStatement(item: unknown): item is WardleyEvolutionStatement {
    return reflection.isInstance(item, WardleyEvolutionStatement.$type);
}

export interface WardleyInertiaProperty extends langium.AstNode {
    readonly $container: WardleyComponentStatement;
    readonly $type: 'WardleyInertiaProperty';
    value: BooleanValue;
}

export const WardleyInertiaProperty = {
    $type: 'WardleyInertiaProperty',
    value: 'value'
} as const;

export function isWardleyInertiaProperty(item: unknown): item is WardleyInertiaProperty {
    return reflection.isInstance(item, WardleyInertiaProperty.$type);
}

export interface WardleyLabelProperty extends langium.AstNode {
    readonly $container: WardleyComponentStatement;
    readonly $type: 'WardleyLabelProperty';
    value: string;
}

export const WardleyLabelProperty = {
    $type: 'WardleyLabelProperty',
    value: 'value'
} as const;

export function isWardleyLabelProperty(item: unknown): item is WardleyLabelProperty {
    return reflection.isInstance(item, WardleyLabelProperty.$type);
}

export interface WardleyProfile extends langium.AstNode {
    readonly $container: Document;
    readonly $type: 'WardleyProfile';
    name: string;
    statements: Array<WardleyStatement>;
}

export const WardleyProfile = {
    $type: 'WardleyProfile',
    name: 'name',
    statements: 'statements'
} as const;

export function isWardleyProfile(item: unknown): item is WardleyProfile {
    return reflection.isInstance(item, WardleyProfile.$type);
}

export type WardleyStatement = WardleyAnchorStatement | WardleyComponentStatement | WardleyDependencyStatement | WardleyEvolutionStatement;

export const WardleyStatement = {
    $type: 'WardleyStatement'
} as const;

export function isWardleyStatement(item: unknown): item is WardleyStatement {
    return reflection.isInstance(item, WardleyStatement.$type);
}

export interface WardleyValueProperty extends langium.AstNode {
    readonly $container: WardleyAnchorStatement | WardleyComponentStatement;
    readonly $type: 'WardleyValueProperty';
    value: string;
}

export const WardleyValueProperty = {
    $type: 'WardleyValueProperty',
    value: 'value'
} as const;

export function isWardleyValueProperty(item: unknown): item is WardleyValueProperty {
    return reflection.isInstance(item, WardleyValueProperty.$type);
}

export interface WeightProperty extends langium.AstNode {
    readonly $container: EdgeDeclaration;
    readonly $type: 'WeightProperty';
    value: string;
}

export const WeightProperty = {
    $type: 'WeightProperty',
    value: 'value'
} as const;

export function isWeightProperty(item: unknown): item is WeightProperty {
    return reflection.isInstance(item, WeightProperty.$type);
}

export interface XLabelProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'XLabelProperty';
    value: string;
}

export const XLabelProperty = {
    $type: 'XLabelProperty',
    value: 'value'
} as const;

export function isXLabelProperty(item: unknown): item is XLabelProperty {
    return reflection.isInstance(item, XLabelProperty.$type);
}

export interface YLabelProperty extends langium.AstNode {
    readonly $container: ShapeDeclaration;
    readonly $type: 'YLabelProperty';
    value: string;
}

export const YLabelProperty = {
    $type: 'YLabelProperty',
    value: 'value'
} as const;

export function isYLabelProperty(item: unknown): item is YLabelProperty {
    return reflection.isInstance(item, YLabelProperty.$type);
}

export type RuniqAstType = {
    AffectedProperty: AffectedProperty
    AnalysisStatement: AnalysisStatement
    ArrowTypeProperty: ArrowTypeProperty
    AttrConstraintsField: AttrConstraintsField
    AttrDefaultField: AttrDefaultField
    AttrDerivedField: AttrDerivedField
    AttrNameField: AttrNameField
    AttrStaticField: AttrStaticField
    AttrTypeField: AttrTypeField
    AttrVisibilityField: AttrVisibilityField
    AttributeDecl: AttributeDecl
    AttributeField: AttributeField
    AttributesProperty: AttributesProperty
    BorderRadiusProperty: BorderRadiusProperty
    BusWidth: BusWidth
    CarrierProperty: CarrierProperty
    ColorsProperty: ColorsProperty
    ConditionalBlock: ConditionalBlock
    ConnectionPoint: ConnectionPoint
    ContainerBlock: ContainerBlock
    ContainerLayoutProperty: ContainerLayoutProperty
    ContainerMetadataProperty: ContainerMetadataProperty
    ContainerProperty: ContainerProperty
    ContainerStyleProperty: ContainerStyleProperty
    ContainerTypeProperty: ContainerTypeProperty
    DataArray: DataArray
    DataItem: DataItem
    DataObject: DataObject
    DataObjectProperty: DataObjectProperty
    DataProperty: DataProperty
    DataSourceDeclaration: DataSourceDeclaration
    DataSourceOption: DataSourceOption
    DataValue: DataValue
    DeceasedProperty: DeceasedProperty
    DiagramProfile: DiagramProfile
    DiagramStatement: DiagramStatement
    DigitalNetStatement: DigitalNetStatement
    DigitalProfile: DigitalProfile
    DigitalStatement: DigitalStatement
    DirectionDeclaration: DirectionDeclaration
    DoActivityProperty: DoActivityProperty
    Document: Document
    EdgeChain: EdgeChain
    EdgeConstraintsProperty: EdgeConstraintsProperty
    EdgeDeclaration: EdgeDeclaration
    EdgeLabelProperty: EdgeLabelProperty
    EdgeProperty: EdgeProperty
    EdgeTypeProperty: EdgeTypeProperty
    EffectProperty: EffectProperty
    ElectricalProfile: ElectricalProfile
    ElectricalStatement: ElectricalStatement
    EntryProperty: EntryProperty
    EventProperty: EventProperty
    ExitProperty: ExitProperty
    ExtensionPointsProperty: ExtensionPointsProperty
    FillColorProperty: FillColorProperty
    FlipAxesProperty: FlipAxesProperty
    FlowRateStatement: FlowRateStatement
    FlowTypeProperty: FlowTypeProperty
    FluidStatement: FluidStatement
    FontFamilyProperty: FontFamilyProperty
    FontSizeProperty: FontSizeProperty
    FontWeightProperty: FontWeightProperty
    ForEachBlock: ForEachBlock
    GatewayTypeProperty: GatewayTypeProperty
    GenericPIDProperty: GenericPIDProperty
    GenericTypesProperty: GenericTypesProperty
    GlyphSetImageItem: GlyphSetImageItem
    GlyphSetItemStatement: GlyphSetItemStatement
    GlyphSetNestedItem: GlyphSetNestedItem
    GlyphSetParameter: GlyphSetParameter
    GlyphSetParameterValue: GlyphSetParameterValue
    GlyphSetProfile: GlyphSetProfile
    GlyphSetSimpleItem: GlyphSetSimpleItem
    GroupBlock: GroupBlock
    GuardProperty: GuardProperty
    HydraulicProfile: HydraulicProfile
    HydraulicStatement: HydraulicStatement
    IconProperty: IconProperty
    InputPinsProperty: InputPinsProperty
    InstMapProperty: InstMapProperty
    InstOfProperty: InstOfProperty
    InstParamsProperty: InstParamsProperty
    InstProperty: InstProperty
    InstStatement: InstStatement
    IntersectionsProperty: IntersectionsProperty
    LabelProperty: LabelProperty
    LabelsProperty: LabelsProperty
    LegendPositionProperty: LegendPositionProperty
    LineStyleProperty: LineStyleProperty
    LinkProperty: LinkProperty
    LoopBlock: LoopBlock
    MethodAbstractField: MethodAbstractField
    MethodConstraintsField: MethodConstraintsField
    MethodDecl: MethodDecl
    MethodField: MethodField
    MethodNameField: MethodNameField
    MethodParamDecl: MethodParamDecl
    MethodParamField: MethodParamField
    MethodParamsField: MethodParamsField
    MethodReturnTypeField: MethodReturnTypeField
    MethodStaticField: MethodStaticField
    MethodVisibilityField: MethodVisibilityField
    MethodsProperty: MethodsProperty
    MetricPositionProperty: MetricPositionProperty
    MetricTypeProperty: MetricTypeProperty
    ModuleParamsProperty: ModuleParamsProperty
    ModulePortsProperty: ModulePortsProperty
    ModuleProperty: ModuleProperty
    ModuleStatement: ModuleStatement
    MultiplicitySourceProperty: MultiplicitySourceProperty
    MultiplicityTargetProperty: MultiplicityTargetProperty
    NavigabilityProperty: NavigabilityProperty
    NetDecl: NetDecl
    NetStatement: NetStatement
    NodeProperty: NodeProperty
    NodeRef: NodeRef
    OpacityProperty: OpacityProperty
    OutputPinsProperty: OutputPinsProperty
    PIDAccuracyProperty: PIDAccuracyProperty
    PIDControlModeProperty: PIDControlModeProperty
    PIDControlledVariableProperty: PIDControlledVariableProperty
    PIDControllerProperty: PIDControllerProperty
    PIDDimensionProperty: PIDDimensionProperty
    PIDEquipmentProperty: PIDEquipmentProperty
    PIDEquipmentStatement: PIDEquipmentStatement
    PIDEquipmentTypeProperty: PIDEquipmentTypeProperty
    PIDFlowRateProperty: PIDFlowRateProperty
    PIDInstrumentProperty: PIDInstrumentProperty
    PIDInstrumentStatement: PIDInstrumentStatement
    PIDInstrumentTypeProperty: PIDInstrumentTypeProperty
    PIDLineFromProperty: PIDLineFromProperty
    PIDLineInsulationProperty: PIDLineInsulationProperty
    PIDLineMaterialProperty: PIDLineMaterialProperty
    PIDLineProperty: PIDLineProperty
    PIDLineScheduleProperty: PIDLineScheduleProperty
    PIDLineSizeProperty: PIDLineSizeProperty
    PIDLineStatement: PIDLineStatement
    PIDLineToProperty: PIDLineToProperty
    PIDLocationProperty: PIDLocationProperty
    PIDLoopProperty: PIDLoopProperty
    PIDLoopRefProperty: PIDLoopRefProperty
    PIDLoopStatement: PIDLoopStatement
    PIDMaterialProperty: PIDMaterialProperty
    PIDProfile: PIDProfile
    PIDRangeProperty: PIDRangeProperty
    PIDRatingProperty: PIDRatingProperty
    PIDSetpointProperty: PIDSetpointProperty
    PIDStatement: PIDStatement
    PIDVolumeProperty: PIDVolumeProperty
    ParamDecl: ParamDecl
    ParamNameField: ParamNameField
    ParamOverride: ParamOverride
    ParamTypeField: ParamTypeField
    PartGenericProperty: PartGenericProperty
    PartPinsProperty: PartPinsProperty
    PartProperty: PartProperty
    PartSourceProperty: PartSourceProperty
    PartStatement: PartStatement
    PartTypeProperty: PartTypeProperty
    PartValueProperty: PartValueProperty
    PneumaticProfile: PneumaticProfile
    PneumaticStatement: PneumaticStatement
    PortConnection: PortConnection
    PortDecl: PortDecl
    PositionProperty: PositionProperty
    PresetBlock: PresetBlock
    PressureStatement: PressureStatement
    Profile: Profile
    RoleSourceProperty: RoleSourceProperty
    RoleTargetProperty: RoleTargetProperty
    RoutingDeclaration: RoutingDeclaration
    RoutingProperty: RoutingProperty
    SequenceActivateProperty: SequenceActivateProperty
    SequenceAlternativeDecl: SequenceAlternativeDecl
    SequenceDurationConstraintProperty: SequenceDurationConstraintProperty
    SequenceDurationConstraintStatement: SequenceDurationConstraintStatement
    SequenceDurationConstraintValueProperty: SequenceDurationConstraintValueProperty
    SequenceDurationFromProperty: SequenceDurationFromProperty
    SequenceDurationToProperty: SequenceDurationToProperty
    SequenceFragmentAlternativesProperty: SequenceFragmentAlternativesProperty
    SequenceFragmentFromProperty: SequenceFragmentFromProperty
    SequenceFragmentGatesProperty: SequenceFragmentGatesProperty
    SequenceFragmentProperty: SequenceFragmentProperty
    SequenceFragmentReferenceProperty: SequenceFragmentReferenceProperty
    SequenceFragmentStatement: SequenceFragmentStatement
    SequenceFragmentToProperty: SequenceFragmentToProperty
    SequenceFromProperty: SequenceFromProperty
    SequenceGuardProperty: SequenceGuardProperty
    SequenceLabelProperty: SequenceLabelProperty
    SequenceMessageProperty: SequenceMessageProperty
    SequenceMessageStatement: SequenceMessageStatement
    SequenceNoteParticipantsProperty: SequenceNoteParticipantsProperty
    SequenceNotePositionProperty: SequenceNotePositionProperty
    SequenceNoteProperty: SequenceNoteProperty
    SequenceNoteStatement: SequenceNoteStatement
    SequenceParticipantStatement: SequenceParticipantStatement
    SequenceProfile: SequenceProfile
    SequenceStateInvariantProperty: SequenceStateInvariantProperty
    SequenceStatement: SequenceStatement
    SequenceTimingProperty: SequenceTimingProperty
    SequenceToProperty: SequenceToProperty
    SequenceTypeProperty: SequenceTypeProperty
    ShapeDeclaration: ShapeDeclaration
    ShowLegendProperty: ShowLegendProperty
    ShowMetricsProperty: ShowMetricsProperty
    ShowValuesProperty: ShowValuesProperty
    StackedProperty: StackedProperty
    StateInvariantProperty: StateInvariantProperty
    StereotypeProperty: StereotypeProperty
    StringArray: StringArray
    StrokeColorProperty: StrokeColorProperty
    StrokeWidthProperty: StrokeWidthProperty
    StyleDeclaration: StyleDeclaration
    StyleProperty: StyleProperty
    StyleRefProperty: StyleRefProperty
    TemplateBlock: TemplateBlock
    TemplateDataProperty: TemplateDataProperty
    TemplateEdgeDeclaration: TemplateEdgeDeclaration
    TemplateEdgeProperty: TemplateEdgeProperty
    TemplateExpression: TemplateExpression
    TemplateExpressionPart: TemplateExpressionPart
    TemplateLiteral: TemplateLiteral
    TemplateNodeDeclaration: TemplateNodeDeclaration
    TemplateNodeProperty: TemplateNodeProperty
    TemplateParameter: TemplateParameter
    TemplateStatement: TemplateStatement
    TemplateVariable: TemplateVariable
    TemplateVariablePath: TemplateVariablePath
    TextAlignProperty: TextAlignProperty
    TextColorProperty: TextColorProperty
    ThemeDeclaration: ThemeDeclaration
    TimelineColorProperty: TimelineColorProperty
    TimelineDateProperty: TimelineDateProperty
    TimelineDescriptionProperty: TimelineDescriptionProperty
    TimelineEndDateProperty: TimelineEndDateProperty
    TimelineEventProperty: TimelineEventProperty
    TimelineEventStatement: TimelineEventStatement
    TimelineIconProperty: TimelineIconProperty
    TimelineLabelProperty: TimelineLabelProperty
    TimelineOpacityProperty: TimelineOpacityProperty
    TimelineOrientationStatement: TimelineOrientationStatement
    TimelinePeriodProperty: TimelinePeriodProperty
    TimelinePeriodStatement: TimelinePeriodStatement
    TimelinePositionProperty: TimelinePositionProperty
    TimelineProfile: TimelineProfile
    TimelineStartDateProperty: TimelineStartDateProperty
    TimelineStatement: TimelineStatement
    TitleProperty: TitleProperty
    TooltipProperty: TooltipProperty
    WardleyAnchorProperty: WardleyAnchorProperty
    WardleyAnchorStatement: WardleyAnchorStatement
    WardleyComponentProperty: WardleyComponentProperty
    WardleyComponentStatement: WardleyComponentStatement
    WardleyDependencyStatement: WardleyDependencyStatement
    WardleyEvolutionProperty: WardleyEvolutionProperty
    WardleyEvolutionStatement: WardleyEvolutionStatement
    WardleyInertiaProperty: WardleyInertiaProperty
    WardleyLabelProperty: WardleyLabelProperty
    WardleyProfile: WardleyProfile
    WardleyStatement: WardleyStatement
    WardleyValueProperty: WardleyValueProperty
    WeightProperty: WeightProperty
    XLabelProperty: XLabelProperty
    YLabelProperty: YLabelProperty
}

export class RuniqAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AffectedProperty: {
            name: AffectedProperty.$type,
            properties: {
                value: {
                    name: AffectedProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        AnalysisStatement: {
            name: AnalysisStatement.$type,
            properties: {
                args: {
                    name: AnalysisStatement.args
                },
                kind: {
                    name: AnalysisStatement.kind
                }
            },
            superTypes: [ElectricalStatement.$type]
        },
        ArrowTypeProperty: {
            name: ArrowTypeProperty.$type,
            properties: {
                value: {
                    name: ArrowTypeProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        AttrConstraintsField: {
            name: AttrConstraintsField.$type,
            properties: {
                values: {
                    name: AttrConstraintsField.values,
                    defaultValue: []
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrDefaultField: {
            name: AttrDefaultField.$type,
            properties: {
                value: {
                    name: AttrDefaultField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrDerivedField: {
            name: AttrDerivedField.$type,
            properties: {
                value: {
                    name: AttrDerivedField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrNameField: {
            name: AttrNameField.$type,
            properties: {
                value: {
                    name: AttrNameField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrStaticField: {
            name: AttrStaticField.$type,
            properties: {
                value: {
                    name: AttrStaticField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrTypeField: {
            name: AttrTypeField.$type,
            properties: {
                value: {
                    name: AttrTypeField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttrVisibilityField: {
            name: AttrVisibilityField.$type,
            properties: {
                value: {
                    name: AttrVisibilityField.value
                }
            },
            superTypes: [AttributeField.$type]
        },
        AttributeDecl: {
            name: AttributeDecl.$type,
            properties: {
                properties: {
                    name: AttributeDecl.properties,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        AttributeField: {
            name: AttributeField.$type,
            properties: {
            },
            superTypes: []
        },
        AttributesProperty: {
            name: AttributesProperty.$type,
            properties: {
                attributes: {
                    name: AttributesProperty.attributes,
                    defaultValue: []
                }
            },
            superTypes: [NodeProperty.$type]
        },
        BorderRadiusProperty: {
            name: BorderRadiusProperty.$type,
            properties: {
                value: {
                    name: BorderRadiusProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        BusWidth: {
            name: BusWidth.$type,
            properties: {
                lsb: {
                    name: BusWidth.lsb
                },
                msb: {
                    name: BusWidth.msb
                }
            },
            superTypes: []
        },
        CarrierProperty: {
            name: CarrierProperty.$type,
            properties: {
                value: {
                    name: CarrierProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ColorsProperty: {
            name: ColorsProperty.$type,
            properties: {
                value: {
                    name: ColorsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ConditionalBlock: {
            name: ConditionalBlock.$type,
            properties: {
                condition: {
                    name: ConditionalBlock.condition
                },
                statements: {
                    name: ConditionalBlock.statements,
                    defaultValue: []
                }
            },
            superTypes: [TemplateStatement.$type]
        },
        ConnectionPoint: {
            name: ConnectionPoint.$type,
            properties: {
                equipment: {
                    name: ConnectionPoint.equipment
                },
                port: {
                    name: ConnectionPoint.port
                }
            },
            superTypes: []
        },
        ContainerBlock: {
            name: ContainerBlock.$type,
            properties: {
                id: {
                    name: ContainerBlock.id
                },
                label: {
                    name: ContainerBlock.label
                },
                properties: {
                    name: ContainerBlock.properties,
                    defaultValue: []
                },
                shape: {
                    name: ContainerBlock.shape
                },
                statements: {
                    name: ContainerBlock.statements,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        ContainerLayoutProperty: {
            name: ContainerLayoutProperty.$type,
            properties: {
                algorithm: {
                    name: ContainerLayoutProperty.algorithm
                },
                direction: {
                    name: ContainerLayoutProperty.direction
                },
                orientation: {
                    name: ContainerLayoutProperty.orientation
                },
                spacing: {
                    name: ContainerLayoutProperty.spacing
                }
            },
            superTypes: [ContainerProperty.$type]
        },
        ContainerMetadataProperty: {
            name: ContainerMetadataProperty.$type,
            properties: {
                badge: {
                    name: ContainerMetadataProperty.badge
                },
                collapseAnimationDuration: {
                    name: ContainerMetadataProperty.collapseAnimationDuration
                },
                collapseAnimationEasing: {
                    name: ContainerMetadataProperty.collapseAnimationEasing
                },
                collapsed: {
                    name: ContainerMetadataProperty.collapsed
                },
                collapseIcon: {
                    name: ContainerMetadataProperty.collapseIcon
                },
                collapseKeyboardShortcut: {
                    name: ContainerMetadataProperty.collapseKeyboardShortcut
                },
                collapseMode: {
                    name: ContainerMetadataProperty.collapseMode
                },
                collapsePersistState: {
                    name: ContainerMetadataProperty.collapsePersistState
                },
                collapseRedirectEdges: {
                    name: ContainerMetadataProperty.collapseRedirectEdges
                },
                collapseShowCount: {
                    name: ContainerMetadataProperty.collapseShowCount
                },
                collapseStateKey: {
                    name: ContainerMetadataProperty.collapseStateKey
                },
                collapseSummary: {
                    name: ContainerMetadataProperty.collapseSummary
                },
                collapseTransitionState: {
                    name: ContainerMetadataProperty.collapseTransitionState
                },
                collapsible: {
                    name: ContainerMetadataProperty.collapsible
                },
                header: {
                    name: ContainerMetadataProperty.header
                },
                icon: {
                    name: ContainerMetadataProperty.icon
                }
            },
            superTypes: [ContainerProperty.$type]
        },
        ContainerProperty: {
            name: ContainerProperty.$type,
            properties: {
            },
            superTypes: []
        },
        ContainerStyleProperty: {
            name: ContainerStyleProperty.$type,
            properties: {
                alignContent: {
                    name: ContainerStyleProperty.alignContent
                },
                autoResize: {
                    name: ContainerStyleProperty.autoResize
                },
                borderStyle: {
                    name: ContainerStyleProperty.borderStyle
                },
                childCountPosition: {
                    name: ContainerStyleProperty.childCountPosition
                },
                collapseButtonColor: {
                    name: ContainerStyleProperty.collapseButtonColor
                },
                collapseButtonPosition: {
                    name: ContainerStyleProperty.collapseButtonPosition
                },
                collapseButtonSize: {
                    name: ContainerStyleProperty.collapseButtonSize
                },
                collapseButtonStyle: {
                    name: ContainerStyleProperty.collapseButtonStyle
                },
                collapseButtonVisible: {
                    name: ContainerStyleProperty.collapseButtonVisible
                },
                crossContainerEdgeOptimization: {
                    name: ContainerStyleProperty.crossContainerEdgeOptimization
                },
                depth: {
                    name: ContainerStyleProperty.depth
                },
                depthIndicatorStyle: {
                    name: ContainerStyleProperty.depthIndicatorStyle
                },
                distribution: {
                    name: ContainerStyleProperty.distribution
                },
                edgeBundling: {
                    name: ContainerStyleProperty.edgeBundling
                },
                edgeRouting: {
                    name: ContainerStyleProperty.edgeRouting
                },
                extends: {
                    name: ContainerStyleProperty.extends
                },
                fillColor: {
                    name: ContainerStyleProperty.fillColor
                },
                headerBackgroundColor: {
                    name: ContainerStyleProperty.headerBackgroundColor
                },
                headerPosition: {
                    name: ContainerStyleProperty.headerPosition
                },
                hoverBorderColor: {
                    name: ContainerStyleProperty.hoverBorderColor
                },
                hoverBorderWidth: {
                    name: ContainerStyleProperty.hoverBorderWidth
                },
                hoverHighlight: {
                    name: ContainerStyleProperty.hoverHighlight
                },
                iconColor: {
                    name: ContainerStyleProperty.iconColor
                },
                iconSize: {
                    name: ContainerStyleProperty.iconSize
                },
                incrementalLayout: {
                    name: ContainerStyleProperty.incrementalLayout
                },
                labelPosition: {
                    name: ContainerStyleProperty.labelPosition
                },
                layoutCache: {
                    name: ContainerStyleProperty.layoutCache
                },
                layoutComplexity: {
                    name: ContainerStyleProperty.layoutComplexity
                },
                margin: {
                    name: ContainerStyleProperty.margin
                },
                marginBottom: {
                    name: ContainerStyleProperty.marginBottom
                },
                marginLeft: {
                    name: ContainerStyleProperty.marginLeft
                },
                marginRight: {
                    name: ContainerStyleProperty.marginRight
                },
                marginTop: {
                    name: ContainerStyleProperty.marginTop
                },
                maxHeight: {
                    name: ContainerStyleProperty.maxHeight
                },
                maxWidth: {
                    name: ContainerStyleProperty.maxWidth
                },
                minHeight: {
                    name: ContainerStyleProperty.minHeight
                },
                minResizeHeight: {
                    name: ContainerStyleProperty.minResizeHeight
                },
                minResizeWidth: {
                    name: ContainerStyleProperty.minResizeWidth
                },
                minWidth: {
                    name: ContainerStyleProperty.minWidth
                },
                nodeSpacing: {
                    name: ContainerStyleProperty.nodeSpacing
                },
                opacity: {
                    name: ContainerStyleProperty.opacity
                },
                padding: {
                    name: ContainerStyleProperty.padding
                },
                paddingBottom: {
                    name: ContainerStyleProperty.paddingBottom
                },
                paddingLeft: {
                    name: ContainerStyleProperty.paddingLeft
                },
                paddingRight: {
                    name: ContainerStyleProperty.paddingRight
                },
                paddingTop: {
                    name: ContainerStyleProperty.paddingTop
                },
                preset: {
                    name: ContainerStyleProperty.preset
                },
                resizable: {
                    name: ContainerStyleProperty.resizable
                },
                resizeHandles: {
                    name: ContainerStyleProperty.resizeHandles,
                    defaultValue: []
                },
                selectionBorderColor: {
                    name: ContainerStyleProperty.selectionBorderColor
                },
                selectionBorderWidth: {
                    name: ContainerStyleProperty.selectionBorderWidth
                },
                selectionHighlight: {
                    name: ContainerStyleProperty.selectionHighlight
                },
                shadow: {
                    name: ContainerStyleProperty.shadow
                },
                showChildCount: {
                    name: ContainerStyleProperty.showChildCount
                },
                showDepthIndicator: {
                    name: ContainerStyleProperty.showDepthIndicator
                },
                strokeColor: {
                    name: ContainerStyleProperty.strokeColor
                },
                strokeWidth: {
                    name: ContainerStyleProperty.strokeWidth
                },
                templateId: {
                    name: ContainerStyleProperty.templateId
                },
                verticalAlign: {
                    name: ContainerStyleProperty.verticalAlign
                }
            },
            superTypes: [ContainerProperty.$type]
        },
        ContainerTypeProperty: {
            name: ContainerTypeProperty.$type,
            properties: {
                type: {
                    name: ContainerTypeProperty.type
                }
            },
            superTypes: [ContainerProperty.$type]
        },
        DataArray: {
            name: DataArray.$type,
            properties: {
                items: {
                    name: DataArray.items,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        DataItem: {
            name: DataItem.$type,
            properties: {
            },
            superTypes: []
        },
        DataObject: {
            name: DataObject.$type,
            properties: {
                properties: {
                    name: DataObject.properties,
                    defaultValue: []
                }
            },
            superTypes: [DataItem.$type]
        },
        DataObjectProperty: {
            name: DataObjectProperty.$type,
            properties: {
                key: {
                    name: DataObjectProperty.key
                },
                value: {
                    name: DataObjectProperty.value
                }
            },
            superTypes: []
        },
        DataProperty: {
            name: DataProperty.$type,
            properties: {
                items: {
                    name: DataProperty.items,
                    defaultValue: []
                }
            },
            superTypes: [NodeProperty.$type]
        },
        DataSourceDeclaration: {
            name: DataSourceDeclaration.$type,
            properties: {
                format: {
                    name: DataSourceDeclaration.format
                },
                key: {
                    name: DataSourceDeclaration.key
                },
                options: {
                    name: DataSourceDeclaration.options,
                    defaultValue: []
                },
                source: {
                    name: DataSourceDeclaration.source
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        DataSourceOption: {
            name: DataSourceOption.$type,
            properties: {
                name: {
                    name: DataSourceOption.name
                },
                value: {
                    name: DataSourceOption.value
                }
            },
            superTypes: []
        },
        DataValue: {
            name: DataValue.$type,
            properties: {
                value: {
                    name: DataValue.value
                }
            },
            superTypes: [DataItem.$type]
        },
        DeceasedProperty: {
            name: DeceasedProperty.$type,
            properties: {
                value: {
                    name: DeceasedProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        DiagramProfile: {
            name: DiagramProfile.$type,
            properties: {
                name: {
                    name: DiagramProfile.name
                },
                statements: {
                    name: DiagramProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        DiagramStatement: {
            name: DiagramStatement.$type,
            properties: {
            },
            superTypes: []
        },
        DigitalNetStatement: {
            name: DigitalNetStatement.$type,
            properties: {
                names: {
                    name: DigitalNetStatement.names,
                    defaultValue: []
                }
            },
            superTypes: [DigitalStatement.$type]
        },
        DigitalProfile: {
            name: DigitalProfile.$type,
            properties: {
                name: {
                    name: DigitalProfile.name
                },
                statements: {
                    name: DigitalProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        DigitalStatement: {
            name: DigitalStatement.$type,
            properties: {
            },
            superTypes: []
        },
        DirectionDeclaration: {
            name: DirectionDeclaration.$type,
            properties: {
                value: {
                    name: DirectionDeclaration.value
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        DoActivityProperty: {
            name: DoActivityProperty.$type,
            properties: {
                value: {
                    name: DoActivityProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        Document: {
            name: Document.$type,
            properties: {
                profiles: {
                    name: Document.profiles,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        EdgeChain: {
            name: EdgeChain.$type,
            properties: {
                anchoredArrow: {
                    name: EdgeChain.anchoredArrow
                },
                arrow: {
                    name: EdgeChain.arrow
                },
                bidirectionalArrow: {
                    name: EdgeChain.bidirectionalArrow
                },
                labeledArrow: {
                    name: EdgeChain.labeledArrow
                },
                to: {
                    name: EdgeChain.to
                }
            },
            superTypes: []
        },
        EdgeConstraintsProperty: {
            name: EdgeConstraintsProperty.$type,
            properties: {
                values: {
                    name: EdgeConstraintsProperty.values,
                    defaultValue: []
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        EdgeDeclaration: {
            name: EdgeDeclaration.$type,
            properties: {
                anchoredArrow: {
                    name: EdgeDeclaration.anchoredArrow
                },
                arrow: {
                    name: EdgeDeclaration.arrow
                },
                bidirectionalArrow: {
                    name: EdgeDeclaration.bidirectionalArrow
                },
                chain: {
                    name: EdgeDeclaration.chain,
                    defaultValue: []
                },
                from: {
                    name: EdgeDeclaration.from
                },
                labeledArrow: {
                    name: EdgeDeclaration.labeledArrow
                },
                properties: {
                    name: EdgeDeclaration.properties,
                    defaultValue: []
                },
                to: {
                    name: EdgeDeclaration.to
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        EdgeLabelProperty: {
            name: EdgeLabelProperty.$type,
            properties: {
                label: {
                    name: EdgeLabelProperty.label
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        EdgeProperty: {
            name: EdgeProperty.$type,
            properties: {
            },
            superTypes: []
        },
        EdgeTypeProperty: {
            name: EdgeTypeProperty.$type,
            properties: {
                value: {
                    name: EdgeTypeProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        EffectProperty: {
            name: EffectProperty.$type,
            properties: {
                value: {
                    name: EffectProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        ElectricalProfile: {
            name: ElectricalProfile.$type,
            properties: {
                name: {
                    name: ElectricalProfile.name
                },
                statements: {
                    name: ElectricalProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        ElectricalStatement: {
            name: ElectricalStatement.$type,
            properties: {
            },
            superTypes: []
        },
        EntryProperty: {
            name: EntryProperty.$type,
            properties: {
                value: {
                    name: EntryProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        EventProperty: {
            name: EventProperty.$type,
            properties: {
                value: {
                    name: EventProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        ExitProperty: {
            name: ExitProperty.$type,
            properties: {
                value: {
                    name: ExitProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ExtensionPointsProperty: {
            name: ExtensionPointsProperty.$type,
            properties: {
                value: {
                    name: ExtensionPointsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        FillColorProperty: {
            name: FillColorProperty.$type,
            properties: {
                value: {
                    name: FillColorProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        FlipAxesProperty: {
            name: FlipAxesProperty.$type,
            properties: {
                value: {
                    name: FlipAxesProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        FlowRateStatement: {
            name: FlowRateStatement.$type,
            properties: {
                unit: {
                    name: FlowRateStatement.unit
                },
                value: {
                    name: FlowRateStatement.value
                }
            },
            superTypes: [HydraulicStatement.$type, PIDStatement.$type, PneumaticStatement.$type]
        },
        FlowTypeProperty: {
            name: FlowTypeProperty.$type,
            properties: {
                value: {
                    name: FlowTypeProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        FluidStatement: {
            name: FluidStatement.$type,
            properties: {
                maxTemp: {
                    name: FluidStatement.maxTemp
                },
                minTemp: {
                    name: FluidStatement.minTemp
                },
                tempUnit: {
                    name: FluidStatement.tempUnit
                },
                type: {
                    name: FluidStatement.type
                },
                viscosity: {
                    name: FluidStatement.viscosity
                }
            },
            superTypes: [HydraulicStatement.$type, PIDStatement.$type]
        },
        FontFamilyProperty: {
            name: FontFamilyProperty.$type,
            properties: {
                value: {
                    name: FontFamilyProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        FontSizeProperty: {
            name: FontSizeProperty.$type,
            properties: {
                value: {
                    name: FontSizeProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        FontWeightProperty: {
            name: FontWeightProperty.$type,
            properties: {
                value: {
                    name: FontWeightProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ForEachBlock: {
            name: ForEachBlock.$type,
            properties: {
                dataKey: {
                    name: ForEachBlock.dataKey
                },
                filter: {
                    name: ForEachBlock.filter
                },
                id: {
                    name: ForEachBlock.id
                },
                limit: {
                    name: ForEachBlock.limit
                },
                statements: {
                    name: ForEachBlock.statements,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        GatewayTypeProperty: {
            name: GatewayTypeProperty.$type,
            properties: {
                value: {
                    name: GatewayTypeProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        GenericPIDProperty: {
            name: GenericPIDProperty.$type,
            properties: {
                key: {
                    name: GenericPIDProperty.key
                },
                value: {
                    name: GenericPIDProperty.value
                }
            },
            superTypes: [PIDEquipmentProperty.$type, PIDInstrumentProperty.$type, PIDLineProperty.$type, PIDLoopProperty.$type]
        },
        GenericTypesProperty: {
            name: GenericTypesProperty.$type,
            properties: {
                types: {
                    name: GenericTypesProperty.types,
                    defaultValue: []
                }
            },
            superTypes: [NodeProperty.$type]
        },
        GlyphSetImageItem: {
            name: GlyphSetImageItem.$type,
            properties: {
                description: {
                    name: GlyphSetImageItem.description
                },
                keyword: {
                    name: GlyphSetImageItem.keyword
                },
                label: {
                    name: GlyphSetImageItem.label
                },
                url: {
                    name: GlyphSetImageItem.url
                }
            },
            superTypes: [GlyphSetItemStatement.$type]
        },
        GlyphSetItemStatement: {
            name: GlyphSetItemStatement.$type,
            properties: {
            },
            superTypes: []
        },
        GlyphSetNestedItem: {
            name: GlyphSetNestedItem.$type,
            properties: {
                children: {
                    name: GlyphSetNestedItem.children,
                    defaultValue: []
                },
                keyword: {
                    name: GlyphSetNestedItem.keyword
                },
                label: {
                    name: GlyphSetNestedItem.label
                },
                relationship: {
                    name: GlyphSetNestedItem.relationship
                }
            },
            superTypes: [GlyphSetItemStatement.$type]
        },
        GlyphSetParameter: {
            name: GlyphSetParameter.$type,
            properties: {
                name: {
                    name: GlyphSetParameter.name
                },
                value: {
                    name: GlyphSetParameter.value
                }
            },
            superTypes: []
        },
        GlyphSetParameterValue: {
            name: GlyphSetParameterValue.$type,
            properties: {
                boolValue: {
                    name: GlyphSetParameterValue.boolValue
                },
                directionValue: {
                    name: GlyphSetParameterValue.directionValue
                },
                numberValue: {
                    name: GlyphSetParameterValue.numberValue
                },
                stringValue: {
                    name: GlyphSetParameterValue.stringValue
                },
                themeValue: {
                    name: GlyphSetParameterValue.themeValue
                }
            },
            superTypes: []
        },
        GlyphSetProfile: {
            name: GlyphSetProfile.$type,
            properties: {
                glyphsetType: {
                    name: GlyphSetProfile.glyphsetType
                },
                items: {
                    name: GlyphSetProfile.items,
                    defaultValue: []
                },
                name: {
                    name: GlyphSetProfile.name
                }
            },
            superTypes: [Profile.$type]
        },
        GlyphSetSimpleItem: {
            name: GlyphSetSimpleItem.$type,
            properties: {
                keyword: {
                    name: GlyphSetSimpleItem.keyword
                },
                label: {
                    name: GlyphSetSimpleItem.label
                },
                relationship: {
                    name: GlyphSetSimpleItem.relationship
                }
            },
            superTypes: [GlyphSetItemStatement.$type]
        },
        GroupBlock: {
            name: GroupBlock.$type,
            properties: {
                label: {
                    name: GroupBlock.label
                },
                statements: {
                    name: GroupBlock.statements,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        GuardProperty: {
            name: GuardProperty.$type,
            properties: {
                value: {
                    name: GuardProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        HydraulicProfile: {
            name: HydraulicProfile.$type,
            properties: {
                name: {
                    name: HydraulicProfile.name
                },
                statements: {
                    name: HydraulicProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        HydraulicStatement: {
            name: HydraulicStatement.$type,
            properties: {
            },
            superTypes: []
        },
        IconProperty: {
            name: IconProperty.$type,
            properties: {
                icon: {
                    name: IconProperty.icon
                },
                provider: {
                    name: IconProperty.provider
                }
            },
            superTypes: [NodeProperty.$type]
        },
        InputPinsProperty: {
            name: InputPinsProperty.$type,
            properties: {
                value: {
                    name: InputPinsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        InstMapProperty: {
            name: InstMapProperty.$type,
            properties: {
                connections: {
                    name: InstMapProperty.connections,
                    defaultValue: []
                }
            },
            superTypes: [InstProperty.$type]
        },
        InstOfProperty: {
            name: InstOfProperty.$type,
            properties: {
                module: {
                    name: InstOfProperty.module
                }
            },
            superTypes: [InstProperty.$type]
        },
        InstParamsProperty: {
            name: InstParamsProperty.$type,
            properties: {
                params: {
                    name: InstParamsProperty.params,
                    defaultValue: []
                }
            },
            superTypes: [InstProperty.$type]
        },
        InstProperty: {
            name: InstProperty.$type,
            properties: {
            },
            superTypes: []
        },
        InstStatement: {
            name: InstStatement.$type,
            properties: {
                properties: {
                    name: InstStatement.properties,
                    defaultValue: []
                },
                ref: {
                    name: InstStatement.ref
                }
            },
            superTypes: [DigitalStatement.$type]
        },
        IntersectionsProperty: {
            name: IntersectionsProperty.$type,
            properties: {
                value: {
                    name: IntersectionsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        LabelProperty: {
            name: LabelProperty.$type,
            properties: {
                value: {
                    name: LabelProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        LabelsProperty: {
            name: LabelsProperty.$type,
            properties: {
                value: {
                    name: LabelsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        LegendPositionProperty: {
            name: LegendPositionProperty.$type,
            properties: {
                value: {
                    name: LegendPositionProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        LineStyleProperty: {
            name: LineStyleProperty.$type,
            properties: {
                value: {
                    name: LineStyleProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        LinkProperty: {
            name: LinkProperty.$type,
            properties: {
                url: {
                    name: LinkProperty.url
                }
            },
            superTypes: [NodeProperty.$type]
        },
        LoopBlock: {
            name: LoopBlock.$type,
            properties: {
                collection: {
                    name: LoopBlock.collection
                },
                statements: {
                    name: LoopBlock.statements,
                    defaultValue: []
                },
                variable: {
                    name: LoopBlock.variable
                }
            },
            superTypes: [TemplateStatement.$type]
        },
        MethodAbstractField: {
            name: MethodAbstractField.$type,
            properties: {
                value: {
                    name: MethodAbstractField.value
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodConstraintsField: {
            name: MethodConstraintsField.$type,
            properties: {
                values: {
                    name: MethodConstraintsField.values,
                    defaultValue: []
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodDecl: {
            name: MethodDecl.$type,
            properties: {
                properties: {
                    name: MethodDecl.properties,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        MethodField: {
            name: MethodField.$type,
            properties: {
            },
            superTypes: []
        },
        MethodNameField: {
            name: MethodNameField.$type,
            properties: {
                value: {
                    name: MethodNameField.value
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodParamDecl: {
            name: MethodParamDecl.$type,
            properties: {
                properties: {
                    name: MethodParamDecl.properties,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        MethodParamField: {
            name: MethodParamField.$type,
            properties: {
            },
            superTypes: []
        },
        MethodParamsField: {
            name: MethodParamsField.$type,
            properties: {
                params: {
                    name: MethodParamsField.params,
                    defaultValue: []
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodReturnTypeField: {
            name: MethodReturnTypeField.$type,
            properties: {
                value: {
                    name: MethodReturnTypeField.value
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodStaticField: {
            name: MethodStaticField.$type,
            properties: {
                value: {
                    name: MethodStaticField.value
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodVisibilityField: {
            name: MethodVisibilityField.$type,
            properties: {
                value: {
                    name: MethodVisibilityField.value
                }
            },
            superTypes: [MethodField.$type]
        },
        MethodsProperty: {
            name: MethodsProperty.$type,
            properties: {
                methods: {
                    name: MethodsProperty.methods,
                    defaultValue: []
                }
            },
            superTypes: [NodeProperty.$type]
        },
        MetricPositionProperty: {
            name: MetricPositionProperty.$type,
            properties: {
                value: {
                    name: MetricPositionProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        MetricTypeProperty: {
            name: MetricTypeProperty.$type,
            properties: {
                value: {
                    name: MetricTypeProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ModuleParamsProperty: {
            name: ModuleParamsProperty.$type,
            properties: {
                params: {
                    name: ModuleParamsProperty.params,
                    defaultValue: []
                }
            },
            superTypes: [ModuleProperty.$type]
        },
        ModulePortsProperty: {
            name: ModulePortsProperty.$type,
            properties: {
                ports: {
                    name: ModulePortsProperty.ports,
                    defaultValue: []
                }
            },
            superTypes: [ModuleProperty.$type]
        },
        ModuleProperty: {
            name: ModuleProperty.$type,
            properties: {
            },
            superTypes: []
        },
        ModuleStatement: {
            name: ModuleStatement.$type,
            properties: {
                name: {
                    name: ModuleStatement.name
                },
                properties: {
                    name: ModuleStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [DigitalStatement.$type]
        },
        MultiplicitySourceProperty: {
            name: MultiplicitySourceProperty.$type,
            properties: {
                value: {
                    name: MultiplicitySourceProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        MultiplicityTargetProperty: {
            name: MultiplicityTargetProperty.$type,
            properties: {
                value: {
                    name: MultiplicityTargetProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        NavigabilityProperty: {
            name: NavigabilityProperty.$type,
            properties: {
                value: {
                    name: NavigabilityProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        NetDecl: {
            name: NetDecl.$type,
            properties: {
                name: {
                    name: NetDecl.name
                },
                width: {
                    name: NetDecl.width
                }
            },
            superTypes: []
        },
        NetStatement: {
            name: NetStatement.$type,
            properties: {
                names: {
                    name: NetStatement.names,
                    defaultValue: []
                }
            },
            superTypes: [ElectricalStatement.$type, HydraulicStatement.$type, PneumaticStatement.$type]
        },
        NodeProperty: {
            name: NodeProperty.$type,
            properties: {
            },
            superTypes: []
        },
        NodeRef: {
            name: NodeRef.$type,
            properties: {
                member: {
                    name: NodeRef.member
                },
                node: {
                    name: NodeRef.node
                }
            },
            superTypes: []
        },
        OpacityProperty: {
            name: OpacityProperty.$type,
            properties: {
                value: {
                    name: OpacityProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        OutputPinsProperty: {
            name: OutputPinsProperty.$type,
            properties: {
                value: {
                    name: OutputPinsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        PIDAccuracyProperty: {
            name: PIDAccuracyProperty.$type,
            properties: {
                unit: {
                    name: PIDAccuracyProperty.unit
                },
                value: {
                    name: PIDAccuracyProperty.value
                }
            },
            superTypes: [PIDInstrumentProperty.$type]
        },
        PIDControlModeProperty: {
            name: PIDControlModeProperty.$type,
            properties: {
                mode: {
                    name: PIDControlModeProperty.mode
                }
            },
            superTypes: [PIDLoopProperty.$type]
        },
        PIDControlledVariableProperty: {
            name: PIDControlledVariableProperty.$type,
            properties: {
                variable: {
                    name: PIDControlledVariableProperty.variable
                }
            },
            superTypes: [PIDLoopProperty.$type]
        },
        PIDControllerProperty: {
            name: PIDControllerProperty.$type,
            properties: {
                tag: {
                    name: PIDControllerProperty.tag
                }
            },
            superTypes: [PIDLoopProperty.$type]
        },
        PIDDimensionProperty: {
            name: PIDDimensionProperty.$type,
            properties: {
                unit: {
                    name: PIDDimensionProperty.unit
                },
                value: {
                    name: PIDDimensionProperty.value
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        PIDEquipmentProperty: {
            name: PIDEquipmentProperty.$type,
            properties: {
            },
            superTypes: []
        },
        PIDEquipmentStatement: {
            name: PIDEquipmentStatement.$type,
            properties: {
                properties: {
                    name: PIDEquipmentStatement.properties,
                    defaultValue: []
                },
                tag: {
                    name: PIDEquipmentStatement.tag
                }
            },
            superTypes: [PIDStatement.$type]
        },
        PIDEquipmentTypeProperty: {
            name: PIDEquipmentTypeProperty.$type,
            properties: {
                type: {
                    name: PIDEquipmentTypeProperty.type
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        PIDFlowRateProperty: {
            name: PIDFlowRateProperty.$type,
            properties: {
                unit: {
                    name: PIDFlowRateProperty.unit
                },
                value: {
                    name: PIDFlowRateProperty.value
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        PIDInstrumentProperty: {
            name: PIDInstrumentProperty.$type,
            properties: {
            },
            superTypes: []
        },
        PIDInstrumentStatement: {
            name: PIDInstrumentStatement.$type,
            properties: {
                properties: {
                    name: PIDInstrumentStatement.properties,
                    defaultValue: []
                },
                tag: {
                    name: PIDInstrumentStatement.tag
                }
            },
            superTypes: [PIDStatement.$type]
        },
        PIDInstrumentTypeProperty: {
            name: PIDInstrumentTypeProperty.$type,
            properties: {
                type: {
                    name: PIDInstrumentTypeProperty.type
                }
            },
            superTypes: [PIDInstrumentProperty.$type]
        },
        PIDLineFromProperty: {
            name: PIDLineFromProperty.$type,
            properties: {
                from: {
                    name: PIDLineFromProperty.from
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLineInsulationProperty: {
            name: PIDLineInsulationProperty.$type,
            properties: {
                type: {
                    name: PIDLineInsulationProperty.type
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLineMaterialProperty: {
            name: PIDLineMaterialProperty.$type,
            properties: {
                material: {
                    name: PIDLineMaterialProperty.material
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLineProperty: {
            name: PIDLineProperty.$type,
            properties: {
            },
            superTypes: []
        },
        PIDLineScheduleProperty: {
            name: PIDLineScheduleProperty.$type,
            properties: {
                schedule: {
                    name: PIDLineScheduleProperty.schedule
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLineSizeProperty: {
            name: PIDLineSizeProperty.$type,
            properties: {
                size: {
                    name: PIDLineSizeProperty.size
                },
                unit: {
                    name: PIDLineSizeProperty.unit
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLineStatement: {
            name: PIDLineStatement.$type,
            properties: {
                lineType: {
                    name: PIDLineStatement.lineType
                },
                properties: {
                    name: PIDLineStatement.properties,
                    defaultValue: []
                },
                style: {
                    name: PIDLineStatement.style
                }
            },
            superTypes: [PIDStatement.$type]
        },
        PIDLineToProperty: {
            name: PIDLineToProperty.$type,
            properties: {
                to: {
                    name: PIDLineToProperty.to
                }
            },
            superTypes: [PIDLineProperty.$type]
        },
        PIDLocationProperty: {
            name: PIDLocationProperty.$type,
            properties: {
                location: {
                    name: PIDLocationProperty.location
                }
            },
            superTypes: [PIDInstrumentProperty.$type]
        },
        PIDLoopProperty: {
            name: PIDLoopProperty.$type,
            properties: {
            },
            superTypes: []
        },
        PIDLoopRefProperty: {
            name: PIDLoopRefProperty.$type,
            properties: {
                loopNum: {
                    name: PIDLoopRefProperty.loopNum
                }
            },
            superTypes: [PIDInstrumentProperty.$type]
        },
        PIDLoopStatement: {
            name: PIDLoopStatement.$type,
            properties: {
                loopNum: {
                    name: PIDLoopStatement.loopNum
                },
                properties: {
                    name: PIDLoopStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [PIDStatement.$type]
        },
        PIDMaterialProperty: {
            name: PIDMaterialProperty.$type,
            properties: {
                material: {
                    name: PIDMaterialProperty.material
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        PIDProfile: {
            name: PIDProfile.$type,
            properties: {
                name: {
                    name: PIDProfile.name
                },
                statements: {
                    name: PIDProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        PIDRangeProperty: {
            name: PIDRangeProperty.$type,
            properties: {
                max: {
                    name: PIDRangeProperty.max
                },
                min: {
                    name: PIDRangeProperty.min
                },
                unit: {
                    name: PIDRangeProperty.unit
                }
            },
            superTypes: [PIDInstrumentProperty.$type]
        },
        PIDRatingProperty: {
            name: PIDRatingProperty.$type,
            properties: {
                rating: {
                    name: PIDRatingProperty.rating
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        PIDSetpointProperty: {
            name: PIDSetpointProperty.$type,
            properties: {
                unit: {
                    name: PIDSetpointProperty.unit
                },
                value: {
                    name: PIDSetpointProperty.value
                }
            },
            superTypes: [PIDLoopProperty.$type]
        },
        PIDStatement: {
            name: PIDStatement.$type,
            properties: {
            },
            superTypes: []
        },
        PIDVolumeProperty: {
            name: PIDVolumeProperty.$type,
            properties: {
                unit: {
                    name: PIDVolumeProperty.unit
                },
                value: {
                    name: PIDVolumeProperty.value
                }
            },
            superTypes: [PIDEquipmentProperty.$type]
        },
        ParamDecl: {
            name: ParamDecl.$type,
            properties: {
                name: {
                    name: ParamDecl.name
                },
                value: {
                    name: ParamDecl.value
                }
            },
            superTypes: []
        },
        ParamNameField: {
            name: ParamNameField.$type,
            properties: {
                value: {
                    name: ParamNameField.value
                }
            },
            superTypes: [MethodParamField.$type]
        },
        ParamOverride: {
            name: ParamOverride.$type,
            properties: {
                param: {
                    name: ParamOverride.param
                },
                value: {
                    name: ParamOverride.value
                }
            },
            superTypes: []
        },
        ParamTypeField: {
            name: ParamTypeField.$type,
            properties: {
                value: {
                    name: ParamTypeField.value
                }
            },
            superTypes: [MethodParamField.$type]
        },
        PartGenericProperty: {
            name: PartGenericProperty.$type,
            properties: {
                key: {
                    name: PartGenericProperty.key
                },
                value: {
                    name: PartGenericProperty.value
                }
            },
            superTypes: [PartProperty.$type]
        },
        PartPinsProperty: {
            name: PartPinsProperty.$type,
            properties: {
                pins: {
                    name: PartPinsProperty.pins,
                    defaultValue: []
                }
            },
            superTypes: [PartProperty.$type]
        },
        PartProperty: {
            name: PartProperty.$type,
            properties: {
            },
            superTypes: []
        },
        PartSourceProperty: {
            name: PartSourceProperty.$type,
            properties: {
                source: {
                    name: PartSourceProperty.source
                }
            },
            superTypes: [PartProperty.$type]
        },
        PartStatement: {
            name: PartStatement.$type,
            properties: {
                properties: {
                    name: PartStatement.properties,
                    defaultValue: []
                },
                ref: {
                    name: PartStatement.ref
                }
            },
            superTypes: [ElectricalStatement.$type, HydraulicStatement.$type, PneumaticStatement.$type]
        },
        PartTypeProperty: {
            name: PartTypeProperty.$type,
            properties: {
                type: {
                    name: PartTypeProperty.type
                }
            },
            superTypes: [PartProperty.$type]
        },
        PartValueProperty: {
            name: PartValueProperty.$type,
            properties: {
                value: {
                    name: PartValueProperty.value
                }
            },
            superTypes: [PartProperty.$type]
        },
        PneumaticProfile: {
            name: PneumaticProfile.$type,
            properties: {
                name: {
                    name: PneumaticProfile.name
                },
                statements: {
                    name: PneumaticProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        PneumaticStatement: {
            name: PneumaticStatement.$type,
            properties: {
            },
            superTypes: []
        },
        PortConnection: {
            name: PortConnection.$type,
            properties: {
                net: {
                    name: PortConnection.net
                },
                port: {
                    name: PortConnection.port
                },
                range: {
                    name: PortConnection.range
                }
            },
            superTypes: []
        },
        PortDecl: {
            name: PortDecl.$type,
            properties: {
                name: {
                    name: PortDecl.name
                },
                width: {
                    name: PortDecl.width
                }
            },
            superTypes: []
        },
        PositionProperty: {
            name: PositionProperty.$type,
            properties: {
                x: {
                    name: PositionProperty.x
                },
                y: {
                    name: PositionProperty.y
                }
            },
            superTypes: [NodeProperty.$type]
        },
        PresetBlock: {
            name: PresetBlock.$type,
            properties: {
                id: {
                    name: PresetBlock.id
                },
                label: {
                    name: PresetBlock.label
                },
                properties: {
                    name: PresetBlock.properties,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        PressureStatement: {
            name: PressureStatement.$type,
            properties: {
                type: {
                    name: PressureStatement.type
                },
                unit: {
                    name: PressureStatement.unit
                },
                value: {
                    name: PressureStatement.value
                }
            },
            superTypes: [HydraulicStatement.$type, PIDStatement.$type, PneumaticStatement.$type]
        },
        Profile: {
            name: Profile.$type,
            properties: {
            },
            superTypes: []
        },
        RoleSourceProperty: {
            name: RoleSourceProperty.$type,
            properties: {
                value: {
                    name: RoleSourceProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        RoleTargetProperty: {
            name: RoleTargetProperty.$type,
            properties: {
                value: {
                    name: RoleTargetProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        RoutingDeclaration: {
            name: RoutingDeclaration.$type,
            properties: {
                value: {
                    name: RoutingDeclaration.value
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        RoutingProperty: {
            name: RoutingProperty.$type,
            properties: {
                value: {
                    name: RoutingProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        SequenceActivateProperty: {
            name: SequenceActivateProperty.$type,
            properties: {
                value: {
                    name: SequenceActivateProperty.value
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceAlternativeDecl: {
            name: SequenceAlternativeDecl.$type,
            properties: {
                fromMsg: {
                    name: SequenceAlternativeDecl.fromMsg
                },
                label: {
                    name: SequenceAlternativeDecl.label
                },
                toMsg: {
                    name: SequenceAlternativeDecl.toMsg
                }
            },
            superTypes: []
        },
        SequenceDurationConstraintProperty: {
            name: SequenceDurationConstraintProperty.$type,
            properties: {
            },
            superTypes: []
        },
        SequenceDurationConstraintStatement: {
            name: SequenceDurationConstraintStatement.$type,
            properties: {
                properties: {
                    name: SequenceDurationConstraintStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [SequenceStatement.$type]
        },
        SequenceDurationConstraintValueProperty: {
            name: SequenceDurationConstraintValueProperty.$type,
            properties: {
                constraint: {
                    name: SequenceDurationConstraintValueProperty.constraint
                }
            },
            superTypes: [SequenceDurationConstraintProperty.$type]
        },
        SequenceDurationFromProperty: {
            name: SequenceDurationFromProperty.$type,
            properties: {
                from: {
                    name: SequenceDurationFromProperty.from
                }
            },
            superTypes: [SequenceDurationConstraintProperty.$type]
        },
        SequenceDurationToProperty: {
            name: SequenceDurationToProperty.$type,
            properties: {
                to: {
                    name: SequenceDurationToProperty.to
                }
            },
            superTypes: [SequenceDurationConstraintProperty.$type]
        },
        SequenceFragmentAlternativesProperty: {
            name: SequenceFragmentAlternativesProperty.$type,
            properties: {
                alternatives: {
                    name: SequenceFragmentAlternativesProperty.alternatives,
                    defaultValue: []
                }
            },
            superTypes: [SequenceFragmentProperty.$type]
        },
        SequenceFragmentFromProperty: {
            name: SequenceFragmentFromProperty.$type,
            properties: {
                from: {
                    name: SequenceFragmentFromProperty.from
                }
            },
            superTypes: [SequenceFragmentProperty.$type]
        },
        SequenceFragmentGatesProperty: {
            name: SequenceFragmentGatesProperty.$type,
            properties: {
                gates: {
                    name: SequenceFragmentGatesProperty.gates,
                    defaultValue: []
                }
            },
            superTypes: [SequenceFragmentProperty.$type]
        },
        SequenceFragmentProperty: {
            name: SequenceFragmentProperty.$type,
            properties: {
            },
            superTypes: []
        },
        SequenceFragmentReferenceProperty: {
            name: SequenceFragmentReferenceProperty.$type,
            properties: {
                ref: {
                    name: SequenceFragmentReferenceProperty.ref
                }
            },
            superTypes: [SequenceFragmentProperty.$type]
        },
        SequenceFragmentStatement: {
            name: SequenceFragmentStatement.$type,
            properties: {
                label: {
                    name: SequenceFragmentStatement.label
                },
                properties: {
                    name: SequenceFragmentStatement.properties,
                    defaultValue: []
                },
                type: {
                    name: SequenceFragmentStatement.type
                }
            },
            superTypes: [SequenceStatement.$type]
        },
        SequenceFragmentToProperty: {
            name: SequenceFragmentToProperty.$type,
            properties: {
                to: {
                    name: SequenceFragmentToProperty.to
                }
            },
            superTypes: [SequenceFragmentProperty.$type]
        },
        SequenceFromProperty: {
            name: SequenceFromProperty.$type,
            properties: {
                from: {
                    name: SequenceFromProperty.from
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceGuardProperty: {
            name: SequenceGuardProperty.$type,
            properties: {
                value: {
                    name: SequenceGuardProperty.value
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceLabelProperty: {
            name: SequenceLabelProperty.$type,
            properties: {
                label: {
                    name: SequenceLabelProperty.label
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceMessageProperty: {
            name: SequenceMessageProperty.$type,
            properties: {
            },
            superTypes: []
        },
        SequenceMessageStatement: {
            name: SequenceMessageStatement.$type,
            properties: {
                properties: {
                    name: SequenceMessageStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [SequenceStatement.$type]
        },
        SequenceNoteParticipantsProperty: {
            name: SequenceNoteParticipantsProperty.$type,
            properties: {
                participants: {
                    name: SequenceNoteParticipantsProperty.participants,
                    defaultValue: []
                }
            },
            superTypes: [SequenceNoteProperty.$type]
        },
        SequenceNotePositionProperty: {
            name: SequenceNotePositionProperty.$type,
            properties: {
                position: {
                    name: SequenceNotePositionProperty.position
                }
            },
            superTypes: [SequenceNoteProperty.$type]
        },
        SequenceNoteProperty: {
            name: SequenceNoteProperty.$type,
            properties: {
            },
            superTypes: []
        },
        SequenceNoteStatement: {
            name: SequenceNoteStatement.$type,
            properties: {
                properties: {
                    name: SequenceNoteStatement.properties,
                    defaultValue: []
                },
                text: {
                    name: SequenceNoteStatement.text
                }
            },
            superTypes: [SequenceStatement.$type]
        },
        SequenceParticipantStatement: {
            name: SequenceParticipantStatement.$type,
            properties: {
                name: {
                    name: SequenceParticipantStatement.name
                },
                type: {
                    name: SequenceParticipantStatement.type
                }
            },
            superTypes: [SequenceStatement.$type]
        },
        SequenceProfile: {
            name: SequenceProfile.$type,
            properties: {
                name: {
                    name: SequenceProfile.name
                },
                statements: {
                    name: SequenceProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        SequenceStateInvariantProperty: {
            name: SequenceStateInvariantProperty.$type,
            properties: {
                value: {
                    name: SequenceStateInvariantProperty.value
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceStatement: {
            name: SequenceStatement.$type,
            properties: {
            },
            superTypes: []
        },
        SequenceTimingProperty: {
            name: SequenceTimingProperty.$type,
            properties: {
                value: {
                    name: SequenceTimingProperty.value
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceToProperty: {
            name: SequenceToProperty.$type,
            properties: {
                to: {
                    name: SequenceToProperty.to
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        SequenceTypeProperty: {
            name: SequenceTypeProperty.$type,
            properties: {
                type: {
                    name: SequenceTypeProperty.type
                }
            },
            superTypes: [SequenceMessageProperty.$type]
        },
        ShapeDeclaration: {
            name: ShapeDeclaration.$type,
            properties: {
                id: {
                    name: ShapeDeclaration.id
                },
                properties: {
                    name: ShapeDeclaration.properties,
                    defaultValue: []
                },
                shape: {
                    name: ShapeDeclaration.shape
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        ShowLegendProperty: {
            name: ShowLegendProperty.$type,
            properties: {
                value: {
                    name: ShowLegendProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ShowMetricsProperty: {
            name: ShowMetricsProperty.$type,
            properties: {
                value: {
                    name: ShowMetricsProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ShowValuesProperty: {
            name: ShowValuesProperty.$type,
            properties: {
                value: {
                    name: ShowValuesProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        StackedProperty: {
            name: StackedProperty.$type,
            properties: {
                value: {
                    name: StackedProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        StateInvariantProperty: {
            name: StateInvariantProperty.$type,
            properties: {
                value: {
                    name: StateInvariantProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        StereotypeProperty: {
            name: StereotypeProperty.$type,
            properties: {
                value: {
                    name: StereotypeProperty.value
                },
                values: {
                    name: StereotypeProperty.values,
                    defaultValue: []
                }
            },
            superTypes: [EdgeProperty.$type, NodeProperty.$type]
        },
        StringArray: {
            name: StringArray.$type,
            properties: {
                items: {
                    name: StringArray.items,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        StrokeColorProperty: {
            name: StrokeColorProperty.$type,
            properties: {
                value: {
                    name: StrokeColorProperty.value
                }
            },
            superTypes: [EdgeProperty.$type, NodeProperty.$type]
        },
        StrokeWidthProperty: {
            name: StrokeWidthProperty.$type,
            properties: {
                value: {
                    name: StrokeWidthProperty.value
                }
            },
            superTypes: [EdgeProperty.$type, NodeProperty.$type]
        },
        StyleDeclaration: {
            name: StyleDeclaration.$type,
            properties: {
                name: {
                    name: StyleDeclaration.name
                },
                properties: {
                    name: StyleDeclaration.properties,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        StyleProperty: {
            name: StyleProperty.$type,
            properties: {
                key: {
                    name: StyleProperty.key
                },
                value: {
                    name: StyleProperty.value
                }
            },
            superTypes: []
        },
        StyleRefProperty: {
            name: StyleRefProperty.$type,
            properties: {
                ref: {
                    name: StyleRefProperty.ref,
                    referenceType: StyleDeclaration.$type
                }
            },
            superTypes: [ContainerProperty.$type, EdgeProperty.$type, NodeProperty.$type]
        },
        TemplateBlock: {
            name: TemplateBlock.$type,
            properties: {
                children: {
                    name: TemplateBlock.children,
                    defaultValue: []
                },
                description: {
                    name: TemplateBlock.description
                },
                id: {
                    name: TemplateBlock.id
                },
                label: {
                    name: TemplateBlock.label
                },
                parameters: {
                    name: TemplateBlock.parameters,
                    defaultValue: []
                },
                properties: {
                    name: TemplateBlock.properties,
                    defaultValue: []
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        TemplateDataProperty: {
            name: TemplateDataProperty.$type,
            properties: {
                key: {
                    name: TemplateDataProperty.key
                },
                value: {
                    name: TemplateDataProperty.value
                }
            },
            superTypes: []
        },
        TemplateEdgeDeclaration: {
            name: TemplateEdgeDeclaration.$type,
            properties: {
                from: {
                    name: TemplateEdgeDeclaration.from
                },
                properties: {
                    name: TemplateEdgeDeclaration.properties,
                    defaultValue: []
                },
                to: {
                    name: TemplateEdgeDeclaration.to
                }
            },
            superTypes: [TemplateStatement.$type]
        },
        TemplateEdgeProperty: {
            name: TemplateEdgeProperty.$type,
            properties: {
                condition: {
                    name: TemplateEdgeProperty.condition
                },
                label: {
                    name: TemplateEdgeProperty.label
                },
                style: {
                    name: TemplateEdgeProperty.style
                }
            },
            superTypes: []
        },
        TemplateExpression: {
            name: TemplateExpression.$type,
            properties: {
                parts: {
                    name: TemplateExpression.parts,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        TemplateExpressionPart: {
            name: TemplateExpressionPart.$type,
            properties: {
            },
            superTypes: []
        },
        TemplateLiteral: {
            name: TemplateLiteral.$type,
            properties: {
                value: {
                    name: TemplateLiteral.value
                }
            },
            superTypes: [TemplateExpressionPart.$type]
        },
        TemplateNodeDeclaration: {
            name: TemplateNodeDeclaration.$type,
            properties: {
                id: {
                    name: TemplateNodeDeclaration.id
                },
                properties: {
                    name: TemplateNodeDeclaration.properties,
                    defaultValue: []
                }
            },
            superTypes: [TemplateStatement.$type]
        },
        TemplateNodeProperty: {
            name: TemplateNodeProperty.$type,
            properties: {
                dataProps: {
                    name: TemplateNodeProperty.dataProps,
                    defaultValue: []
                },
                fillColor: {
                    name: TemplateNodeProperty.fillColor
                },
                label: {
                    name: TemplateNodeProperty.label
                },
                shape: {
                    name: TemplateNodeProperty.shape
                },
                strokeColor: {
                    name: TemplateNodeProperty.strokeColor
                },
                style: {
                    name: TemplateNodeProperty.style
                }
            },
            superTypes: []
        },
        TemplateParameter: {
            name: TemplateParameter.$type,
            properties: {
                defaultValue: {
                    name: TemplateParameter.defaultValue
                },
                name: {
                    name: TemplateParameter.name
                },
                type: {
                    name: TemplateParameter.type
                }
            },
            superTypes: []
        },
        TemplateStatement: {
            name: TemplateStatement.$type,
            properties: {
            },
            superTypes: []
        },
        TemplateVariable: {
            name: TemplateVariable.$type,
            properties: {
                path: {
                    name: TemplateVariable.path
                }
            },
            superTypes: [TemplateExpressionPart.$type]
        },
        TemplateVariablePath: {
            name: TemplateVariablePath.$type,
            properties: {
                segments: {
                    name: TemplateVariablePath.segments,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        TextAlignProperty: {
            name: TextAlignProperty.$type,
            properties: {
                value: {
                    name: TextAlignProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        TextColorProperty: {
            name: TextColorProperty.$type,
            properties: {
                value: {
                    name: TextColorProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        ThemeDeclaration: {
            name: ThemeDeclaration.$type,
            properties: {
                value: {
                    name: ThemeDeclaration.value
                }
            },
            superTypes: [DiagramStatement.$type]
        },
        TimelineColorProperty: {
            name: TimelineColorProperty.$type,
            properties: {
                color: {
                    name: TimelineColorProperty.color
                }
            },
            superTypes: [TimelineEventProperty.$type, TimelinePeriodProperty.$type]
        },
        TimelineDateProperty: {
            name: TimelineDateProperty.$type,
            properties: {
                date: {
                    name: TimelineDateProperty.date
                }
            },
            superTypes: [TimelineEventProperty.$type]
        },
        TimelineDescriptionProperty: {
            name: TimelineDescriptionProperty.$type,
            properties: {
                description: {
                    name: TimelineDescriptionProperty.description
                }
            },
            superTypes: [TimelineEventProperty.$type]
        },
        TimelineEndDateProperty: {
            name: TimelineEndDateProperty.$type,
            properties: {
                endDate: {
                    name: TimelineEndDateProperty.endDate
                }
            },
            superTypes: [TimelinePeriodProperty.$type]
        },
        TimelineEventProperty: {
            name: TimelineEventProperty.$type,
            properties: {
            },
            superTypes: []
        },
        TimelineEventStatement: {
            name: TimelineEventStatement.$type,
            properties: {
                id: {
                    name: TimelineEventStatement.id
                },
                properties: {
                    name: TimelineEventStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [TimelineStatement.$type]
        },
        TimelineIconProperty: {
            name: TimelineIconProperty.$type,
            properties: {
                icon: {
                    name: TimelineIconProperty.icon
                }
            },
            superTypes: [TimelineEventProperty.$type]
        },
        TimelineLabelProperty: {
            name: TimelineLabelProperty.$type,
            properties: {
                label: {
                    name: TimelineLabelProperty.label
                }
            },
            superTypes: [TimelineEventProperty.$type, TimelinePeriodProperty.$type]
        },
        TimelineOpacityProperty: {
            name: TimelineOpacityProperty.$type,
            properties: {
                opacity: {
                    name: TimelineOpacityProperty.opacity
                }
            },
            superTypes: [TimelinePeriodProperty.$type]
        },
        TimelineOrientationStatement: {
            name: TimelineOrientationStatement.$type,
            properties: {
                orientation: {
                    name: TimelineOrientationStatement.orientation
                }
            },
            superTypes: [TimelineStatement.$type]
        },
        TimelinePeriodProperty: {
            name: TimelinePeriodProperty.$type,
            properties: {
            },
            superTypes: []
        },
        TimelinePeriodStatement: {
            name: TimelinePeriodStatement.$type,
            properties: {
                id: {
                    name: TimelinePeriodStatement.id
                },
                properties: {
                    name: TimelinePeriodStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [TimelineStatement.$type]
        },
        TimelinePositionProperty: {
            name: TimelinePositionProperty.$type,
            properties: {
                position: {
                    name: TimelinePositionProperty.position
                }
            },
            superTypes: [TimelineEventProperty.$type]
        },
        TimelineProfile: {
            name: TimelineProfile.$type,
            properties: {
                name: {
                    name: TimelineProfile.name
                },
                statements: {
                    name: TimelineProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        TimelineStartDateProperty: {
            name: TimelineStartDateProperty.$type,
            properties: {
                startDate: {
                    name: TimelineStartDateProperty.startDate
                }
            },
            superTypes: [TimelinePeriodProperty.$type]
        },
        TimelineStatement: {
            name: TimelineStatement.$type,
            properties: {
            },
            superTypes: []
        },
        TitleProperty: {
            name: TitleProperty.$type,
            properties: {
                value: {
                    name: TitleProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        TooltipProperty: {
            name: TooltipProperty.$type,
            properties: {
                text: {
                    name: TooltipProperty.text
                }
            },
            superTypes: [NodeProperty.$type]
        },
        WardleyAnchorProperty: {
            name: WardleyAnchorProperty.$type,
            properties: {
            },
            superTypes: []
        },
        WardleyAnchorStatement: {
            name: WardleyAnchorStatement.$type,
            properties: {
                name: {
                    name: WardleyAnchorStatement.name
                },
                properties: {
                    name: WardleyAnchorStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [WardleyStatement.$type]
        },
        WardleyComponentProperty: {
            name: WardleyComponentProperty.$type,
            properties: {
            },
            superTypes: []
        },
        WardleyComponentStatement: {
            name: WardleyComponentStatement.$type,
            properties: {
                name: {
                    name: WardleyComponentStatement.name
                },
                properties: {
                    name: WardleyComponentStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [WardleyStatement.$type]
        },
        WardleyDependencyStatement: {
            name: WardleyDependencyStatement.$type,
            properties: {
                from: {
                    name: WardleyDependencyStatement.from
                },
                to: {
                    name: WardleyDependencyStatement.to
                }
            },
            superTypes: [WardleyStatement.$type]
        },
        WardleyEvolutionProperty: {
            name: WardleyEvolutionProperty.$type,
            properties: {
                value: {
                    name: WardleyEvolutionProperty.value
                }
            },
            superTypes: [WardleyAnchorProperty.$type, WardleyComponentProperty.$type]
        },
        WardleyEvolutionStatement: {
            name: WardleyEvolutionStatement.$type,
            properties: {
                component: {
                    name: WardleyEvolutionStatement.component
                },
                properties: {
                    name: WardleyEvolutionStatement.properties,
                    defaultValue: []
                }
            },
            superTypes: [WardleyStatement.$type]
        },
        WardleyInertiaProperty: {
            name: WardleyInertiaProperty.$type,
            properties: {
                value: {
                    name: WardleyInertiaProperty.value
                }
            },
            superTypes: [WardleyComponentProperty.$type]
        },
        WardleyLabelProperty: {
            name: WardleyLabelProperty.$type,
            properties: {
                value: {
                    name: WardleyLabelProperty.value
                }
            },
            superTypes: [WardleyComponentProperty.$type]
        },
        WardleyProfile: {
            name: WardleyProfile.$type,
            properties: {
                name: {
                    name: WardleyProfile.name
                },
                statements: {
                    name: WardleyProfile.statements,
                    defaultValue: []
                }
            },
            superTypes: [Profile.$type]
        },
        WardleyStatement: {
            name: WardleyStatement.$type,
            properties: {
            },
            superTypes: []
        },
        WardleyValueProperty: {
            name: WardleyValueProperty.$type,
            properties: {
                value: {
                    name: WardleyValueProperty.value
                }
            },
            superTypes: [WardleyAnchorProperty.$type, WardleyComponentProperty.$type]
        },
        WeightProperty: {
            name: WeightProperty.$type,
            properties: {
                value: {
                    name: WeightProperty.value
                }
            },
            superTypes: [EdgeProperty.$type]
        },
        XLabelProperty: {
            name: XLabelProperty.$type,
            properties: {
                value: {
                    name: XLabelProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        },
        YLabelProperty: {
            name: YLabelProperty.$type,
            properties: {
                value: {
                    name: YLabelProperty.value
                }
            },
            superTypes: [NodeProperty.$type]
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new RuniqAstReflection();

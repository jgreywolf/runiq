/**
 * GlyphSet expansion logic for parser
 *
 * When a diagram uses `glyphset:pattern-name`, this module expands it
 * into a complete diagram AST by invoking the appropriate glyphset generator.
 */

import type { DiagramAst } from '@runiq/core';
import { glyphsetRegistry, GlyphSetError } from '@runiq/glyphsets';
import * as Langium from './generated/ast.js';

/**
 * Check if a profile is a GlyphSetProfile
 */
export function isGlyphSetProfile(profile: Langium.Profile): profile is Langium.GlyphSetProfile {
  return Langium.isGlyphSetProfile(profile);
}

/**
 * Extract parameters from glyphset item statements
 *
 * Maps statement types to parameter names:
 * - step "X" -> steps: ["X"]
 * - level "Y" -> levels: ["Y"]
 * - quadrant "Z" -> quadrants: ["Z"]
 * etc.
 */
function extractGlyphSetParams(
  statements: Langium.GlyphSetItemStatement[]
): Record<string, unknown> {
  const params: Record<string, unknown> = {};

  // Collect items by type
  const steps: string[] = [];
  const items: string[] = [];
  const levels: string[] = [];
  const stages: string[] = [];
  const events: string[] = [];
  const quadrants: string[] = [];
  const circles: string[] = [];

  for (const stmt of statements) {
    const label = stmt.label.replace(/^"|"$/g, ''); // Remove quotes

    // Check which keyword was used and add to appropriate array
    const text = stmt.$cstNode?.text || '';
    if (text.startsWith('step')) {
      steps.push(label);
    } else if (text.startsWith('item')) {
      items.push(label);
    } else if (text.startsWith('level')) {
      levels.push(label);
    } else if (text.startsWith('stage')) {
      stages.push(label);
    } else if (text.startsWith('event')) {
      events.push(label);
    } else if (text.startsWith('quadrant')) {
      quadrants.push(label);
    } else if (text.startsWith('circle')) {
      circles.push(label);
    }
  }

  // Add non-empty arrays to params with appropriate names
  if (steps.length > 0) params.steps = steps;
  if (items.length > 0) params.items = items;
  if (levels.length > 0) params.levels = levels;
  if (stages.length > 0) params.stages = stages;
  if (events.length > 0) params.events = events;
  if (quadrants.length > 0) params.quadrants = quadrants;
  if (circles.length > 0) params.circles = circles;

  return params;
}

/**
 * Expand a GlyphSetProfile into a complete DiagramAst
 *
 * @param profile The Langium GlyphSetProfile
 * @returns Complete DiagramAst generated by the glyphset
 * @throws GlyphSetError if glyphset not found or invalid
 */
export function expandGlyphSet(profile: Langium.GlyphSetProfile): DiagramAst {
  const glyphsetId = profile.glyphsetType;

  // Look up the glyphset
  const glyphset = glyphsetRegistry.get(glyphsetId);

  if (!glyphset) {
    throw new GlyphSetError(
      glyphsetId,
      undefined,
      `Unknown glyphset "${glyphsetId}". Available glyphsets: ${glyphsetRegistry.getAllIds().join(', ')}`
    );
  }

  // Extract parameters from glyphset items
  const params = extractGlyphSetParams(profile.items);

  // Generate the diagram using the glyphset
  try {
    const diagram = glyphset.generator(params);

    return {
      ...diagram,
      // Preserve any metadata
      _glyphsetId: glyphsetId,
      _glyphsetParams: params,
    } as DiagramAst;
  } catch (error) {
    if (error instanceof GlyphSetError) {
      throw error;
    }
    throw new GlyphSetError(
      glyphsetId,
      undefined,
      `Error generating glyphset "${glyphsetId}": ${(error as Error).message}`
    );
  }
}

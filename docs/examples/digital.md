# Digital Logic Examples

Design digital circuits with gate-level schematics and Verilog HDL export for synthesis and simulation.

::: info Coming soon
Rendered SVG visuals for schematic profiles are coming soon. The DSL snippets below use the `electrical` profile for gate-level logic; see the [Digital Circuits Guide](/guide/digital-circuits) for `digital { ... }` module syntax.
:::

## Half Adder

Basic combinational circuit that adds two single bits.

### DSL Code

```runiq
electrical "Half Adder" {
  net A, B, SUM, CARRY

  part U1 type:XOR pins:(A,B,SUM)
  part U2 type:AND pins:(A,B,CARRY)
}
```

### Truth Table

| A   | B   | SUM | CARRY |
| --- | --- | --- | ----- |
| 0   | 0   | 0   | 0     |
| 0   | 1   | 1   | 0     |
| 1   | 0   | 1   | 0     |
| 1   | 1   | 0   | 1     |

### Logic Equations

$$\text{SUM} = A \oplus B$$
$$\text{CARRY} = A \cdot B$$

### Exported Verilog

```verilog
// Half Adder
// Generated by Runiq

module half_adder(
  input wire A,
  input wire B,
  output wire SUM,
  output wire CARRY
);

  xor U1(SUM, A, B);
  and U2(CARRY, A, B);

endmodule
```

## Full Adder

Adds three bits (two inputs plus carry-in).

### DSL Code

```runiq
electrical "Full Adder" {
  net A, B, CIN, SUM, COUT
  net SUM1, CARRY1, CARRY2

  part U1 type:XOR pins:(A,B,SUM1)
  part U2 type:AND pins:(A,B,CARRY1)
  part U3 type:XOR pins:(SUM1,CIN,SUM)
  part U4 type:AND pins:(SUM1,CIN,CARRY2)
  part U5 type:OR pins:(CARRY1,CARRY2,COUT)
}
```

### Truth Table

| A   | B   | CIN | SUM | COUT |
| --- | --- | --- | --- | ---- |
| 0   | 0   | 0   | 0   | 0    |
| 0   | 0   | 1   | 1   | 0    |
| 0   | 1   | 0   | 1   | 0    |
| 0   | 1   | 1   | 0   | 1    |
| 1   | 0   | 0   | 1   | 0    |
| 1   | 0   | 1   | 0   | 1    |
| 1   | 1   | 0   | 0   | 1    |
| 1   | 1   | 1   | 1   | 1    |

### Logic Equations

$$\text{SUM} = A \oplus B \oplus C_{IN}$$
$$C_{OUT} = AB + (A \oplus B)C_{IN}$$

## 2-to-1 Multiplexer

Selects one of two inputs based on a select signal.

### DSL Code

```runiq
electrical "2-to-1 Multiplexer" {
  net D0, D1, SEL, Y
  net SEL_N, T0, T1

  part U1 type:NOT pins:(SEL,SEL_N)
  part U2 type:AND pins:(D0,SEL_N,T0)
  part U3 type:AND pins:(D1,SEL,T1)
  part U4 type:OR pins:(T0,T1,Y)
}
```

### Truth Table

| SEL | D0  | D1  | Y   |
| --- | --- | --- | --- |
| 0   | 0   | X   | 0   |
| 0   | 1   | X   | 1   |
| 1   | X   | 0   | 0   |
| 1   | X   | 1   | 1   |

### Logic Equation

$$Y = \overline{\text{SEL}} \cdot D_0 + \text{SEL} \cdot D_1$$

## CMOS Inverter

Complementary MOSFET inverter - the basic building block of digital logic.

### DSL Code

```runiq
electrical "CMOS Inverter" {
  net VDD, IN, OUT, GND

  # Power supply: 5V
  part VDD type:V source:"DC 5" pins:(VDD,GND)

  # Input signal: pulse from 0 to 5V
  part VIN type:V source:"PULSE(0 5 0 1n 1n 10n 20n)" pins:(IN,GND)

  # PMOS pull-up (on when input is low)
  part MP type:M model:"PMOS" pins:(VDD,IN,OUT)

  # NMOS pull-down (on when input is high)
  part MN type:M model:"NMOS" pins:(OUT,IN,GND)

  # Output load capacitance
  part CL type:C value:"1p" pins:(OUT,GND)

  # Transient analysis
  analysis tran "0 100n"
}
```

### Generated SVG

![CMOS Inverter](/examples/cmos-inverter.svg)

### Operation

| Input (VIN) | PMOS | NMOS | Output (VOUT) |
| ----------- | ---- | ---- | ------------- |
| LOW (0V)    | ON   | OFF  | HIGH (VDD)    |
| HIGH (VDD)  | OFF  | ON   | LOW (0V)      |

**Power Consumption**: Only during switching (dynamic power)

**Use Cases**:

- NOT gate implementation
- Buffer circuits
- Basic logic building block
- Low-power digital design

## D Flip-Flop

Basic sequential element with clock.

### DSL Code

```runiq
electrical "D Flip-Flop" {
  net D, CLK, Q, Q_N

  part FF1 type:DFF pins:(D,CLK,Q,Q_N)
}
```

### Operation

- **D**: Data input
- **CLK**: Clock signal (rising edge triggered)
- **Q**: Output follows D on clock rising edge
- **Q_N**: Inverted output

### Timing Diagram

```
CLK: ___|--|___|--|___|--|___
D:   ___|--|__|--|___|--|__|--|___
Q:   ________|--|__|--|___|--|__
```

## 4-Bit Counter

Sequential circuit that counts from 0 to 15.

### DSL Code

```runiq
electrical "4-Bit Counter" {
  net T, CLK, Q0, Q1, Q2, Q3

  // Tie T high for continuous toggling
  part FF0 type:TFF pins:(T,CLK,Q0)
  part FF1 type:TFF pins:(T,Q0,Q1)
  part FF2 type:TFF pins:(T,Q1,Q2)
  part FF3 type:TFF pins:(T,Q2,Q3)
}
```

### Count Sequence

| CLK | Q3  | Q2  | Q1  | Q0  | Decimal  |
| --- | --- | --- | --- | --- | -------- |
| 0   | 0   | 0   | 0   | 0   | 0        |
| 1   | 0   | 0   | 0   | 1   | 1        |
| 2   | 0   | 0   | 1   | 0   | 2        |
| 3   | 0   | 0   | 1   | 1   | 3        |
| ... | ... | ... | ... | ... | ...      |
| 15  | 1   | 1   | 1   | 1   | 15       |
| 16  | 0   | 0   | 0   | 0   | 0 (wrap) |

## Supported Gate Types

Runiq supports standard digital logic gates:

### Basic Gates

| Gate     | Type   | Inputs | Function                    |
| -------- | ------ | ------ | --------------------------- |
| **NOT**  | `NOT`  | 1      | $Y = \overline{A}$          |
| **AND**  | `AND`  | 2+     | $Y = A \cdot B$             |
| **OR**   | `OR`   | 2+     | $Y = A + B$                 |
| **NAND** | `NAND` | 2+     | $Y = \overline{A \cdot B}$  |
| **NOR**  | `NOR`  | 2+     | $Y = \overline{A + B}$      |
| **XOR**  | `XOR`  | 2      | $Y = A \oplus B$            |
| **XNOR** | `XNOR` | 2      | $Y = \overline{A \oplus B}$ |

### Sequential Elements

| Element          | Type   | Description                       |
| ---------------- | ------ | --------------------------------- |
| **D Flip-Flop**  | `DFF`  | Data flip-flop (edge-triggered)   |
| **T Flip-Flop**  | `TFF`  | Toggle flip-flop                  |
| **JK Flip-Flop** | `JKFF` | JK flip-flop (most versatile)     |
| **SR Latch**     | `SR`   | Set-reset latch (level-sensitive) |

### Syntax

```runiq
# Combinational gate
part <ID> type:<TYPE> pins:(<in1>,<in2>,...,<out>)

# Sequential element
part <ID> type:<TYPE> pins:(<D>,<CLK>,<Q>,<Q_N>)
```

## Complete Examples

### 1-Bit ALU (Combinational)

```runiq
electrical "1-Bit ALU" {
  net A, B, S0, S1, Y
  net Y_AND, Y_OR, Y_XOR, Y_NOT

  part AND1 type:AND pins:(A,B,Y_AND)
  part OR1 type:OR pins:(A,B,Y_OR)
  part XOR1 type:XOR pins:(A,B,Y_XOR)
  part NOT1 type:NOT pins:(A,Y_NOT)

  // Select between AND/OR/XOR/NOT using S1:S0
  part MUX1 type:MUX41 pins:(Y_AND,Y_OR,Y_XOR,Y_NOT,S0,S1,Y)
}
```

### 8-Bit Shift Register

```runiq
electrical "8-Bit Shift Register" {
  net SERIAL_IN, CLK
  net Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7

  part FF0 type:DFF pins:(SERIAL_IN,CLK,Q0)
  part FF1 type:DFF pins:(Q0,CLK,Q1)
  part FF2 type:DFF pins:(Q1,CLK,Q2)
  part FF3 type:DFF pins:(Q2,CLK,Q3)
  part FF4 type:DFF pins:(Q3,CLK,Q4)
  part FF5 type:DFF pins:(Q4,CLK,Q5)
  part FF6 type:DFF pins:(Q5,CLK,Q6)
  part FF7 type:DFF pins:(Q6,CLK,Q7)
}
```

## Best Practices

::: tip Gate Naming

- Use descriptive IDs: `U_AND_GATE`, `FF_DATA`, `MUX_SELECT`
- Number related gates: `ADD0`, `ADD1`, `ADD2`, etc.
- Indicate function: `INV_CLK`, `OR_OUT`, `DFF_Q0`
  :::

::: tip Bus Notation
Use bit vectors for multi-bit signals:

```runiq
input DATA[7:0]    # 8-bit input
output ADDR[15:0]  # 16-bit output
wire TEMP[3:0]     # 4-bit internal signal
```

:::

::: tip Clock and Reset

- Always include `CLK` for sequential circuits
- Add `RST` (reset) for initialization
- Use consistent names: `CLK`, `RST`, `EN` (enable)
  :::

## Export to Verilog

Generate Verilog HDL for:

- **Simulation**: ModelSim, Icarus Verilog, Verilator
- **Synthesis**: Vivado (Xilinx), Quartus (Intel), Yosys
- **FPGA Programming**: Deploy to real hardware

```bash
# Generate Verilog
runiq half-adder.runiq --export verilog -o half_adder.v

# Simulate with Icarus Verilog
iverilog -o half_adder half_adder.v half_adder_tb.v
vvp half_adder
```

## Verification

Always verify your designs with:

1. **Truth tables** - Enumerate all input combinations
2. **Timing diagrams** - Check sequential behavior
3. **Testbenches** - Write Verilog testbenches
4. **Simulation** - Run with HDL simulator
5. **Synthesis** - Check for optimization opportunities

## Next Steps

- [Electrical Circuits](/examples/electrical) - Analog schematics with SPICE
- [Control System Diagrams](/examples/control-diagrams) - System-level design
- [Reference](/reference/shapes) - All digital symbols

---

## Download Examples

All example `.runiq` files are available in the [GitHub repository](https://github.com/jgreywolf/runiq/tree/main/examples/digital).

```bash
git clone https://github.com/jgreywolf/runiq.git
cd runiq/examples/digital
```


